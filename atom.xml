<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Thorn&#39;s Blog</title>
  
  <subtitle>奔跑 跌倒 奔跑</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://thorns.cn/"/>
  <updated>2019-08-29T05:35:16.981Z</updated>
  <id>https://thorns.cn/</id>
  
  <author>
    <name>Thorn</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>生活没有答案，但总有下一站</title>
    <link href="https://thorns.cn/2019/08/29/life_MD.html"/>
    <id>https://thorns.cn/2019/08/29/life_MD.html</id>
    <published>2019-08-29T00:05:00.000Z</published>
    <updated>2019-08-29T05:35:16.981Z</updated>
    
    <content type="html"><![CDATA[<h1 id="生活没有答案，但总有下一站"><a href="#生活没有答案，但总有下一站" class="headerlink" title="生活没有答案，但总有下一站"></a>生活没有答案，但总有下一站</h1><blockquote><p>生活没有答案，但总有下一个站</p></blockquote><h2 id="黑夜中寻找那丝微光"><a href="#黑夜中寻找那丝微光" class="headerlink" title="黑夜中寻找那丝微光"></a>黑夜中寻找那丝微光</h2><p>&emsp;到沙漠公路的时候这次环疆就宣告了结束，一个人骑到了塔里木胡杨林景区就没有再往前行驶，记得要开始骑沙漠的时候我给我朋友说“不想骑了”，朋友立马着急的打电话过来问我“是骑不动了？还是真的就不想骑了，不骑完你回来一周就会后悔的！”，“不想骑了”…   </p><p>我也不知道为什么不想骑了，或许是沙漠里面天太热？景色太单一审美疲劳了？还是一个人太无聊枯燥了？不是的，我还有更重要的事情要去做，我还没去兰州在大西北灰蒙蒙的清晨吃上一碗正宗的兰州拉面听上一曲《金城兰州》，也还没去定西背靠贫瘠的山陵街道上，端着一碗地道的定西洋芋小吃听着那么一句</p><blockquote><p>“这么多年，你一个人一直在走，<br>方向和天气的节奏会让你哀愁”</p></blockquote><p>也要路过那座有情有义有米可炊的城市——郑州，去写下一份关于我自己的《关于郑州的记忆》。我想没有比这个更重要的事了！这些羁绊的东西在黑夜里折磨着我却又给我指好行驶的方向，让我去寻找那丝微光，真的没有骗你。</p><h2 id="生活没有答案"><a href="#生活没有答案" class="headerlink" title="生活没有答案"></a>生活没有答案</h2><p>&emsp;骑完了，历时十六天，一千四百多公里，没多远。那一刻我想把一切都丢掉，丢掉…车子丢在沙漠公路的终点，把衣服清洁好捐出去，空身回家就带一个人。可我没有那勇气，就像出来那样没有勇气，我以为一路下来会有个答案，会有个结果。躺在宾馆的白床铺上，“我太俗了，怎么会以为有个answerer给我一个answer”，没有的，有的只是路上的花，马牛羊在山坡上吃草和在公路上奔跑。他说</p><blockquote><p>“生活是苦难的，我又划着我的断桨出发了”</p></blockquote><p>前半句我其实是不赞同的，相反我更喜欢那句</p><blockquote><p>“生活在于它的不确定性”  </p></blockquote><p>&emsp;你不会知道明天的你是依然过着这重复着重复着重复的日子，还是在遥远看得见光的下面奔跑，是不确定的，也不会有先知在你睡不着的夜晚来告诉你一个答案。生活没有答案。</p><h2 id="下一个车站"><a href="#下一个车站" class="headerlink" title="下一个车站"></a>下一个车站</h2><p>&emsp;“各位旅客你们好，下一站兰州车站，请各位要下车的旅客，提前收拾好你们的行李，准备下车” ，背上了包下了火车，出站口的那一刻阳光洒在我脸上，我忍不住给它比了摇滚的手势，像个孩子似的在广场大声欢呼（当然我也不会在乎旁人的看法）做上131到中山桥的公交车，还是喜欢坐在下站门口的前排靠窗位置，打开手机准备写一点东西来记录回忆，突然映入我眼前的一个蓝底牌子白色三个大字“定西路”，我想立即下车最终还是忍住了，因为我知道这里是兰州不是定西。随即我又想起我咋忘买一包兰州了，怎么会把这个事情给忘记了呢？我不知道，但总想着等公交车到了下一个车站，我就去买一包兰州，等动车开往定西的时候，我就拿起手机“咔嚓”一下拍个照，等下一个车站，在下一个车站，总会有我们期待已久，懊悔过许久，能给我们一丝慰藉。也许下一站需要很久，半小时，五小时，甚至四十八小时，甚至更久…乃至活到出头。<br>&emsp;但我真的在下一站见到七八十岁的老奶奶老大爷在欢声歌唱，没有骗你。<br><img src="http://image.thorns.cn/12312.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;生活没有答案，但总有下一站&quot;&gt;&lt;a href=&quot;#生活没有答案，但总有下一站&quot; class=&quot;headerlink&quot; title=&quot;生活没有答案，但总有下一站&quot;&gt;&lt;/a&gt;生活没有答案，但总有下一站&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;生活没有答案，但总有下一个
      
    
    </summary>
    
      <category term="“旅途”" scheme="https://thorns.cn/categories/%E2%80%9C%E6%97%85%E9%80%94%E2%80%9D/"/>
    
    
  </entry>
  
  <entry>
    <title>等他回来</title>
    <link href="https://thorns.cn/2019/07/15/waitforhimtocomeback.html"/>
    <id>https://thorns.cn/2019/07/15/waitforhimtocomeback.html</id>
    <published>2019-07-15T04:30:30.000Z</published>
    <updated>2019-07-15T02:59:33.455Z</updated>
    
    <content type="html"><![CDATA[<h1 id="等他回来"><a href="#等他回来" class="headerlink" title="等他回来"></a>等他回来</h1><blockquote><p>我想等到他回来的那一天,那一天无论身在何处我都会奔着去看他的演出。</p></blockquote><a id="more"></a><p>&emsp;看到身边的朋友都在大喊“痛仰牛逼”，“裤子还是新的好”，“喜欢刺猬的鼓手”,心里面也一阵高兴，我也很喜欢这些，喜欢痛苦的信仰,喜欢没有理想的人不伤心开啤酒的那一下，喜欢刺猬的女鼓手摇滚范儿<br>&emsp;可心底总有一种莫名的情愫笼罩着我——那个男人还是没回来,哎…！让我打不起精神。看到朋友圈有人在分享这首歌,那首歌，我也想分享一首来着，一打开网易云搜索”李志”，查无此人。不知不觉间打开Chrome,想搜索一些东西,又很自然的输入了那个名字,又看了一遍维基百科的介绍,我也不知道从多久我开始这样,心里面难免有点失落和茫然…</p><blockquote><p>真想问一句“妈妈,这种失落会持久吗？”   </p></blockquote><p>所以呀,无论多久,多久都等,等他回来的第一场演出,我们一起相约2000.<br><img src="http://image.thorns.cn/1.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;等他回来&quot;&gt;&lt;a href=&quot;#等他回来&quot; class=&quot;headerlink&quot; title=&quot;等他回来&quot;&gt;&lt;/a&gt;等他回来&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;我想等到他回来的那一天,那一天无论身在何处我都会奔着去看他的演出。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="李志" scheme="https://thorns.cn/categories/%E6%9D%8E%E5%BF%97/"/>
    
    
  </entry>
  
  <entry>
    <title>ARTS 第三周</title>
    <link href="https://thorns.cn/2019/04/06/ARTS_3.html"/>
    <id>https://thorns.cn/2019/04/06/ARTS_3.html</id>
    <published>2019-04-06T09:58:30.000Z</published>
    <updated>2019-04-06T15:45:56.394Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>What’s ARTS？<br>A:Algorithm 每周至少做一个leetcode的算法题<br>R:Review 阅读并点评至少一遍英文技术文章<br>T:Tip 学习至少一个技术技巧<br>S:Share 分享一篇有观点和思考的技术文章  </p></blockquote><h2 id="1-Algorithm"><a href="#1-Algorithm" class="headerlink" title="1. Algorithm"></a>1. Algorithm</h2><blockquote><p>Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.<br>给定一个字符串s，在s中找出最长回文子串。你可以假设s的最大长度为s。</p></blockquote><p>&emsp;这道题难度为Medium，有很多种解法,自己刚开始想到的是使用暴力法去暴力破解，不过这种方法的时间复杂度太高，先枚举所有子串，对每个子串进行判断是否为回文，此种方法的时间复杂度为O(n^3),在网上看到有人用动态规划的方法，遂学习了下动态规划，关于动态规划——想单独写一篇文章记录下，就不在这里介绍了。代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">string longestPalindrome(string s)</span><br><span class="line">&#123;</span><br><span class="line">    if (!s.size())</span><br><span class="line">        return &quot;&quot;;</span><br><span class="line">    int len = s.size();</span><br><span class="line">    int left = 0,right = 0;</span><br><span class="line">    bool dp[len][len];</span><br><span class="line">    dp[0][0] = true;</span><br><span class="line">    for (int i = 1;i&lt;len;++i) &#123;</span><br><span class="line">        dp[i][i] = true;</span><br><span class="line">        dp[i][i-1] = true;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 2;i &lt;= len;++i) &#123;</span><br><span class="line">        for (int j = 0;j &lt;= len-i;++j) &#123;</span><br><span class="line">            if (s[j]==s[len-i-1] &amp;&amp; dp[j+1][j+i-2]) &#123;</span><br><span class="line">                dp[j][i+j-1] = true;</span><br><span class="line">                if (right-left+1 &lt; i) &#123;</span><br><span class="line">                    left = j;</span><br><span class="line">                    right = j+i-1</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return s.substr(left,right-left+1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-Review"><a href="#2-Review" class="headerlink" title="2. Review"></a>2. Review</h2><p>&emsp;先上链接<a href="https://www.codechef.com/wiki/tutorial-dynamic-programming" target="_blank" rel="noopener">Tutorial For Dynamic programming</a><br>&emsp;该文章讲解了Dynamic programming(动态规划)，分别举例说明了DP的两种形式</p><blockquote><p>&emsp;There are two ways of doing this.<br>&emsp;1.) Top-Down : Start solving the given problem by breaking it down. If you see that the problem has been solved already, then just return the saved answer. If it has not been solved, solve it and save the answer. This is usually easy to think of and very intuitive. This is referred to as Memoization.<br>&emsp;2.) Bottom-Up : Analyze the problem and see the order in which the sub-problems are solved and start solving from the trivial subproblem, up towards the given problem. In this process, it is guaranteed that the subproblems are solved before solving the problem. This is referred to as Dynamic Programming. </p></blockquote><h3 id="2-1-Memoization"><a href="#2-1-Memoization" class="headerlink" title="2.1 Memoization"></a>2.1 Memoization</h3><p>&emsp;第一种自顶向下的方法，通过分解来解决给定的问题。如果你发现问题已经解决，就只需要返回已保存的答案，如果尚未解决，请解决并保存答案。这种方法被称为Memoization(备忘录法)。  </p><blockquote><p>&emsp;Recursion uses the top-down approach to solve the problem i.e. It begin with core(main) problem then breaks it into subproblems and solve these subproblems similarily. In this approach same subproblem can occur multiple times and consume more CPU cycle ,hence increase the time complexity. Whereas in Dynamic programming same subproblem will not be solved multiple times but the prior result will be used to optimise the solution. eg. In fibonacci series   </p></blockquote><p>&emsp;自顶向上的方法通常使用递归求解，即它从核心(主要)问题开始，然后将其分解为子问题并解决这些类似的子问题。在这种方法中，相同的子问题可能会多次出现并消耗更多的CPU周期，因此这种解决方法增加时间复杂度</p><h3 id="2-2-Dynamic-Programming"><a href="#2-2-Dynamic-Programming" class="headerlink" title="2.2 Dynamic Programming"></a>2.2 Dynamic Programming</h3><p>&emsp;第二种自底向上的方法，分析问题并查看子问题被解决的顺序，并从子问题开始解决问题，在此过程中，保证在解决问题之前解决子问题，这就是所谓的动态规划。<br>&emsp;关于动态规划会在另一篇博客中详细的介绍、记录一下。  </p><h3 id="2-3-Remark"><a href="#2-3-Remark" class="headerlink" title="2.3 Remark"></a>2.3 Remark</h3><p>&emsp;这篇文章详细的介绍了动态规划的概念，并通过三个问题一一讲解了Memoization和DP这两种解决方法的区别，总的来说是一篇非常不错很适合像我这种之前都不知道DP的人，一看就能懂就会的文章。值得mark</p><h2 id="3-Tips"><a href="#3-Tips" class="headerlink" title="3. Tips"></a>3. Tips</h2><p>最近有使用到docker，在这里简单说下docker一些基础的操作命令  </p><ol><li>docker pull 从镜像仓库拉取指定镜像</li><li>docker images 查看本地所有镜像</li><li>docker rmi 删除本地一个或多个镜像</li><li>docker ps 查看正在运行的容器</li><li>docker ps -a 查看所有容器</li><li>docker run 运行容器,通常使用-it以交互模式运行容器</li><li>docker top 查看容器中运行的进程信息</li><li>docker start/stop/restart 对容器的操作</li><li>docker rm 删除一个容器或多个容器</li></ol><h2 id="4-Share"><a href="#4-Share" class="headerlink" title="4. Share"></a>4. Share</h2><p>分享的还是跟动态规划有关，这个使用漫画的形式，非常详细的介绍了动态规划，几乎纯小白一看就能懂的文章  <a href="https://zhuanlan.zhihu.com/p/31628866" target="_blank" rel="noopener">文章链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;What’s ARTS？&lt;br&gt;A:Algorithm 每周至少做一个leetcode的算法题&lt;br&gt;R:Review 阅读并点评至少一遍英文技术文章&lt;br&gt;T:Tip 学习至少一个技术技巧&lt;br&gt;S:Share 分享一篇有观点和思考的技术文章  
      
    
    </summary>
    
      <category term="ARTS" scheme="https://thorns.cn/categories/ARTS/"/>
    
    
  </entry>
  
  <entry>
    <title>ARTS 第二周  欢迎交流讨论</title>
    <link href="https://thorns.cn/2019/03/31/arts_2.html"/>
    <id>https://thorns.cn/2019/03/31/arts_2.html</id>
    <published>2019-03-31T11:33:47.000Z</published>
    <updated>2019-03-31T13:48:16.597Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>What’s ARTS？<br>A:Algorithm 每周至少做一个leetcode的算法题<br>R:Review 阅读并点评至少一遍英文技术文章<br>T:Tip 学习至少一个技术技巧<br>S:Share 分享一篇有观点和思考的技术文章  </p></blockquote><h2 id="1-Algorithm"><a href="#1-Algorithm" class="headerlink" title="1.Algorithm"></a>1.Algorithm</h2><p>Longest Substring Without Repeating Characters，找出最长且不重复的子串<br>Example 1:   </p><blockquote><p>Input:&emsp;”abcabcbb”<br>Output:&emsp;”3”<br>Explanation: The answer is “abc”, with the length of 3</p></blockquote><p>Example 2:  </p><blockquote><p>Input:&emsp;”pwwkew”<br>Output:&emsp;”3”<br>Explanation: The answer is “wke”, with the length of 3.<br>             Note that the answer must be a substring, “pwke” is a subsequence and not a </p></blockquote><p>此题可以通过滑动窗口的思想来解决，代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int lengthOfLongestSubstring(string s)</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; arr(128,-1);</span><br><span class="line">    int left = -1,res = 0;  //滑动窗口的左边和返回值</span><br><span class="line">    for (int i = 0;i &lt; s.size();++i) &#123;</span><br><span class="line">        left = max(left,arr[s[i]);</span><br><span class="line">        arr[s[i] = i;</span><br><span class="line">        res = max(res,i-left);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-Review"><a href="#2-Review" class="headerlink" title="2.Review"></a>2.Review</h2><p><a href="https://medium.com/@mr_mig_by/how-do-i-learn-some-functional-programming-3b28875a0bc3" target="_blank" rel="noopener">我该怎样去学习一些函数式编程?</a><br>本篇文章从OOD到函数式编程，没过于讲解技术上面的知识，不过作者推荐了一些文章讲述了该怎么去学习函数式编程，比如第一推荐了《Function JavaScript》,和使用underscore library，当熟练了这些下一步就可以深入。《JavaScript Allongé》,《Professor Frisby’s Mostly Adequate Guide to Functional Programming.》，并且还推荐了haskell。这篇文章主要是”Tell us how to learn it”，对函数式编程感兴趣的朋友可以点击阅读下</p><h2 id="3-Tip"><a href="#3-Tip" class="headerlink" title="3.Tip"></a>3.Tip</h2><p>关于Tip，说一下这周学的怎么计算子网地址，子网掩码和一个子网内主机数吧<br>例如一个IP地址是203.123.1.135,子网掩码是255.255.255.192   </p><p>那子网地址:就是用IP地址和子网掩码进行按位与运算，这里也就是132&amp;192=128，所以子网地址这个ip地址对应的子网地址是203.123.1.128</p><p>子网主机数:将子网掩码转成二进制,11111111.11111111.11111111.11000000 其中为1的表示网络位，为0表示主机位。主机位总共占6位，主机数就等于2^6-2=62，减去的2代表的是 子网地址和直接广播地址。</p><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>这周没什么分享的，因为最近这一两个月都太忙了，工作上、生活上，自我学习上都挺忙的，没有什么太值得分享的东西。倒是可以分享下之前感到很郁闷的东西，我朋友大概知道 相对于技术，我一直比较反感windows下mfc开发的那一套和不太愿意去接触web端的东西，不过最近工作上从duilib到mfc是干的真的很糟心，没有激情没有想去学习mfc的动力，所以以致于工作上出现很多问题。  </p><p>过渡了一个月，看到耗子叔的专栏，心态有了些变化。正如专栏里说的和我自己理解的，其实自己并不是反感windows，偏好linux开发。反而是由于linux简单，windows比较复杂产生的抵抗情绪。调节了一下心态，活到老，学到老。I’m not perfect.But I keep trying.</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><blockquote><p>PS:能把心态调节过来，个人认为跟自己最近阅读的书籍有一定联系，所以在这里也推荐几本刚刚看完的书，希望小伙伴们能一起交流。  </p><p>《一个人的朝圣》 很多人认为是鸡汤，其实我并不这样认为，作者只不过是讲述了哈罗德一个人朝圣的故事与你我无关<br>《情人》  小波同志力荐的一本小说<br>《海边的卡夫卡》</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;What’s ARTS？&lt;br&gt;A:Algorithm 每周至少做一个leetcode的算法题&lt;br&gt;R:Review 阅读并点评至少一遍英文技术文章&lt;br&gt;T:Tip 学习至少一个技术技巧&lt;br&gt;S:Share 分享一篇有观点和思考的技术文章  
      
    
    </summary>
    
      <category term="ARTS" scheme="https://thorns.cn/categories/ARTS/"/>
    
    
  </entry>
  
  <entry>
    <title>ARTS 打卡第一周</title>
    <link href="https://thorns.cn/2019/03/23/ARTS_1.html"/>
    <id>https://thorns.cn/2019/03/23/ARTS_1.html</id>
    <published>2019-03-22T16:39:47.000Z</published>
    <updated>2019-03-22T16:44:56.904Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>What’s ARTS？<br>A:Algorithm 每周至少做一个leetcode的算法题<br>R:Review 阅读并点评至少一遍英文技术文章<br>T:Tip 学习至少一个技术技巧<br>S:Share 分享一篇有观点和思考的技术文章  </p></blockquote><font size="5">ARTS打卡第一周</font><h2 id="1-Algorithm"><a href="#1-Algorithm" class="headerlink" title="1.Algorithm"></a>1.Algorithm</h2><p>&emsp;本周做了几个难度为Easy的算法，记录下。</p><h3 id="1-1-Palindromic-number"><a href="#1-1-Palindromic-number" class="headerlink" title="1.1 Palindromic number"></a>1.1 Palindromic number</h3><p>&emsp;判断一个数是否为回文数,方法很简单，只需要逆置前后判断是否相等就行了，不过还是有几个地方需要注意下   </p><p>&emsp;1. 负数、个位上为0的数都不是回文数<br>&emsp;2. 注意int类型的溢出  </p><p>&emsp;代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">bool determine(int num)</span><br><span class="line">&#123;</span><br><span class="line">    if (num &lt; 0 ||(num != 0) &amp;&amp; num %10 ==0)</span><br><span class="line">        return false;</span><br><span class="line">    int x = 0;</span><br><span class="line">    while (num &gt; x) &#123;</span><br><span class="line">        x = num % 10 + x * 10;</span><br><span class="line">        num /= 10;</span><br><span class="line">    &#125;</span><br><span class="line">    return num == x || (x / 10 == y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="1-2-Roman-To-Intger"><a href="#1-2-Roman-To-Intger" class="headerlink" title="1.2 Roman To Intger"></a>1.2 Roman To Intger</h3><p>&emsp;将罗马数字转换为整数，此题感觉主要考查对罗马数字的转换熟悉不，当一个罗马数字前面部分小于后面部分，就是使用后面部分减去前面部分，否则就是加。第一时间想到的是直接使用个switch进行判断就好了,不过这样不够简洁，到最后发现有更简洁的办法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">int romantoint(string str)</span><br><span class="line">&#123;</span><br><span class="line">    int num[26] = &#123;0&#125;;</span><br><span class="line">    num[&apos;I&apos;-&apos;A&apos;] = 1;</span><br><span class="line">    num[&apos;V&apos;-&apos;A&apos;] = 5;</span><br><span class="line">    num[&apos;X&apos;-&apos;A&apos;] = 10;</span><br><span class="line">    num[&apos;L&apos;-&apos;A&apos;] = 50;</span><br><span class="line">    num[&apos;C&apos;-&apos;A&apos;] = 100;</span><br><span class="line">    num[&apos;D&apos;-&apos;A&apos;] = 500;</span><br><span class="line">    num[&apos;M&apos;-&apos;A&apos;] = 1000;</span><br><span class="line">    </span><br><span class="line">    int sum = 0;</span><br><span class="line">    for (size_t i = 0; i &lt; str.size(); ++i) &#123;</span><br><span class="line">        if (i+1 = str.size()) &#123;</span><br><span class="line">            sum += num[str[i]-&apos;A&apos;];</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        if (num[str[i]-&apos;A&apos;] &gt;= num[str[i+1]-&apos;A&apos;]) </span><br><span class="line">            sum += num[str[i]-&apos;A&apos;];</span><br><span class="line">        else &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            sum += num[str[i]-&apos;A&apos;] - num[str[i-1]-&apos;A&apos;];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-Review"><a href="#2-Review" class="headerlink" title="2.Review"></a>2.Review</h2><p>&emsp;<a href="https://medium.com/@calebleak/fast-virtual-functions-hacking-the-vtable-for-fun-and-profit-25c36409c5e0" target="_blank" rel="noopener">文章链接-需要能打开Google才能打开</a><br>&emsp;这篇文章讲述了C++虚函数的性能开销，从重载、override 多态一步步到虚函数，写的很详细。也从各方面分析了虚函数的开销，主要体现在虚函数调用需要间接跳转带来的分支预测成本和cache miss，文章中也讲了该如何尽可能的去最小化cache miss，通过虚函数分组的办法使用std::set来进行分组{函数指针,对象指针},通过分组将函数调用保存在缓存中最小化cache miss。</p><h2 id="3-Tip"><a href="#3-Tip" class="headerlink" title="3.Tip"></a>3.Tip</h2><p>&emsp;前面先说一下，感觉学习真的是一个不断完善、不断修剪的过程，本周学到的tips都跟上面讲的文章相关。看到文章中提到的cache miss，才知道cache miss是什么东西，也才学会使用linux下的性能调优工具perf.  </p><ol><li><p>perf list 查看perf能监控哪些性能指标 主要有三类指标<br>1.1 Hardware Event 是由PMU硬件产生的事件 比如cache命中<br>1.2 Software Event 由内核产生，比如进程切换,page-faults等<br>1.3 TracePoint Event 是核心中的静态 tracepoint 所触发的事件，这些 tracepoint 用來判断在程序执行时期核心的行为  </p></li><li><p>perf stat -e -L1-dcache-load-misses ./test  查看test程序的L1 cache miss的指标</p></li></ol><h2 id="4-Share"><a href="#4-Share" class="headerlink" title="4. Share"></a>4. Share</h2><p>关于技术文章,这周看的比较多的是耗子叔的文章，里面有一篇很有意思，讲的是“魔数 Ox5f3759df” ，主要讲的是求平方根，硬是看了好几遍，才看懂，后面又看到用牛顿迭代法求平方根，都很不错，分享给大家，有兴趣的小伙伴可以留言一起讨论讨论。<br><a href="https://matongxue.com/madocs/205.html" target="_blank" rel="noopener">如何通俗易懂地讲解牛顿迭代法–戳我打开</a>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;What’s ARTS？&lt;br&gt;A:Algorithm 每周至少做一个leetcode的算法题&lt;br&gt;R:Review 阅读并点评至少一遍英文技术文章&lt;br&gt;T:Tip 学习至少一个技术技巧&lt;br&gt;S:Share 分享一篇有观点和思考的技术文章  
      
    
    </summary>
    
      <category term="ARTS" scheme="https://thorns.cn/categories/ARTS/"/>
    
    
      <category term="ARTS" scheme="https://thorns.cn/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>C++ 单例模式 双检锁问题</title>
    <link href="https://thorns.cn/2019/03/09/DCLP.html"/>
    <id>https://thorns.cn/2019/03/09/DCLP.html</id>
    <published>2019-03-09T06:35:40.000Z</published>
    <updated>2019-03-09T09:21:08.315Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-单例模式和双检锁问题"><a href="#C-单例模式和双检锁问题" class="headerlink" title="C++ 单例模式和双检锁问题"></a>C++ 单例模式和双检锁问题</h1><blockquote><p>最近在看《程序员的自我修养》这本书，从代码的编译到链接，从虚拟空间映射物理空间，到内存的分配无一不通通展开。以前对编译，链接不了解、疑惑的地方在看这本书时都有一种豁然开朗的感觉，特此记录一下。</p></blockquote><p>&emsp;在设计模式中，单例模式算的上最容易理解简单，且经常用到的一种模式。单例模式又分为“饿汉式”和“懒汉式”两种模式。  </p><ul><li>懒汉式:需要类的实例化时去判断唯一实例是否被实例化，如果没有才会去创建实例</li><li>饿汉式:在类定义的时候，唯一实例就已经进行实例化，后面需要用到时，直接返回唯一实例</li></ul><h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//单线程安全</span><br><span class="line">T *GetInstance()</span><br><span class="line">&#123;</span><br><span class="line">    if (pInst == NULL)</span><br><span class="line">        pInst = new T;</span><br><span class="line">    return pInst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码，是单线程安全的，但并不是多线程安全。考虑一下有两个线程A和B，同时调用了GetInstance方法又恰巧检测到pInst为NULL，这时就出问题了，产生了两个实例，这并不是我们想要的。接下来，我们肯定会想到线程不安全加锁就完了嘛。  </p><h2 id="双检锁-懒汉式"><a href="#双检锁-懒汉式" class="headerlink" title="双检锁-懒汉式"></a>双检锁-懒汉式</h2><p>下面是经典的加锁懒汉式实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">T *GetInstance()</span><br><span class="line">&#123;</span><br><span class="line">    //进行double-check,降低多线程每次调用lock带来的开销</span><br><span class="line">    if (pInst == NULL) &#123;</span><br><span class="line">        lock();</span><br><span class="line">        if (pInst == NULL)</span><br><span class="line">            pInst = new T;</span><br><span class="line">        unlock();      </span><br><span class="line">    &#125;</span><br><span class="line">    return pInst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;这里的双重if检测(double-check)，是为了降低多线程每次调用lock带来的开销。也许当我们看到这样的代码时，认为并没有问题，实际上是有问题的，问题来自CPU的乱序执行。<br>&emsp;我们知道C++的new，包含了两个步骤   </p><blockquote><ol><li>分配内存  </li><li>调用构造函数  </li></ol></blockquote><p>&emsp;所以pInst=new T包含了三个步骤</p><blockquote><ol><li>分配内存  </li><li>调用构造函数</li><li>将分配好的内存地址赋值给pInst </li></ol></blockquote><p>事实上在cpu执行的时候，步骤2和3是可以颠倒的，他们看上去像这样  </p><blockquote><ol><li>调用operator new()分配内存  </li><li>使pInst指向分配好的内存</li><li>调用构造函数constructor  </li></ol></blockquote><p>那在多线程的情况下，就可能会出现A线程刚好分配好内存，并赋值给pInst，B线程再次调用GetInstance方法，此时pInst已经不为空了，所以就会出现将一个还并没有构造完毕的对象直接返回给用户使用，此时问题就出现了</p><h2 id="解决方法，使用barrier指令"><a href="#解决方法，使用barrier指令" class="headerlink" title="解决方法，使用barrier指令"></a>解决方法，使用barrier指令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#define barrier() __asm__ volatile (&quot;lwsync&quot;)</span><br><span class="line">T *GetInstance()</span><br><span class="line">&#123;</span><br><span class="line">    if (pInst == NULL) &#123;</span><br><span class="line">        lock();</span><br><span class="line">        if (pInst == NULL) &#123;</span><br><span class="line">            T *temp = new T;</span><br><span class="line">            barrier();</span><br><span class="line">            pInst = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        unlock();      </span><br><span class="line">    &#125;</span><br><span class="line">    return pInst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;通常情况下是调用cpu提供的一条指令，这条指令的作用是会阻止cpu将该指令之前的指令交换到该指令之后，这条指令也通常被叫做barrier。 上面代码中的<strong>asm</strong>表示这个是一条汇编指令，volatile是可选的，如果用了它，则表示向编译器声明不允许对该汇编指令进行优化。lwsync是POWERPC提供的barrier指令。<br>&emsp;最后,在C++11中，关于C++双检锁的问题，已经完全解决了，有兴趣的朋友可以去看下C++11 DCLP</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-单例模式和双检锁问题&quot;&gt;&lt;a href=&quot;#C-单例模式和双检锁问题&quot; class=&quot;headerlink&quot; title=&quot;C++ 单例模式和双检锁问题&quot;&gt;&lt;/a&gt;C++ 单例模式和双检锁问题&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;最近在看《程序员的自我修养
      
    
    </summary>
    
      <category term="C++" scheme="https://thorns.cn/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>蒲公英和炊烟都在等你</title>
    <link href="https://thorns.cn/2019/01/19/dandelion.html"/>
    <id>https://thorns.cn/2019/01/19/dandelion.html</id>
    <published>2019-01-18T20:27:00.000Z</published>
    <updated>2019-07-15T03:15:23.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="蒲公英和炊烟都在等你"><a href="#蒲公英和炊烟都在等你" class="headerlink" title="蒲公英和炊烟都在等你"></a>蒲公英和炊烟都在等你</h1><blockquote><p>蒲公英和炊烟都在等你，你的孩子一直很乖  </p></blockquote><p><img src="http://image.thorns.cn/mama.jpeg" alt="avatar"><br>&emsp;睡下的时候，应是周五的十一点十几分，挂断了朋友的电话对他轻轻的讲了句”我要睡了”。收拾好因找不到一包烟，被我翻的乱七八糟的房间，躺在床上，记忆中很久没有这么早睡过了，不知道为什么从跨年去南京一趟，回来到现在整个人都很累，有身体上的疲惫有精神上的面对。   </p><p>&emsp;我想今天晚上或许会有点不同，房间是干净的，昏黄的灯光折射出十来平的小窝，显得别具一格的宽阔不会被人潮拥挤。脑海中回响”四点多的时候应该会醒来”，醒来时却发现比预想提前了两个小时。总感觉会发生点什么，在这个夜晚会不一样。</p><h2 id="1-19-2-53"><a href="#1-19-2-53" class="headerlink" title="1.19 2:53"></a>1.19 2:53</h2><p>在 1月19日凌晨两点五十三分床上的手机屏幕亮了，像是久违的一束阳光照在我脸膛，手机屏幕传来的是网易云音乐上别人给我点赞的消息，是我在李志的《妈妈》下面</p><blockquote><p>“我想这首歌 评论没有上万。都是害怕去听吧。”     </p></blockquote><p>&emsp;这首歌按李逼一贯的风格有很多个版本，最先发布在《这个世界会好吗》专辑下，还有“13live”,“14io”，个人听歌比较钟爱于live，追求真实，身入其镜的感觉。也就开始了“13live版”的《妈妈》。</p><h2 id="红色推土机"><a href="#红色推土机" class="headerlink" title="红色推土机"></a>红色推土机</h2><p>&emsp;也许是某一天，实在忍受不了没日没夜的单曲循环，发了疯似的把李志的歌全部收集到了歌单里面，列表循环在歌声缓缓流入耳朵不经意间发现了《妈妈》这首歌还有另外一个不为大众知道的版本，——“红色推土机”  </p><p>&emsp;故事的开始貌似都是以时间作分割。</p><blockquote><p>09年，民谣歌手周云蓬发起了一个帮助贫困盲童的计划。目的是为那些家境贫困的失明孩子，购买他们需要的乐器、mp3播放器、读书机。   为了让更多的人知道这个计划，周云蓬邀请众多民谣歌手无偿录制了一个童谣专辑，每个歌手或翻唱、或原创一首童谣歌曲，一共25首儿歌收录在两张CD中，专辑名字为《红色推土机》。这张专辑把当下“新民谣”阵营里的歌手一网打尽，称得上是民谣歌手的一张全家福。而这些创作音乐人，在这一次的专辑里，也从往日的角色中越轨而出，放下沉重，低吟浅唱，唱给暂时的黑暗和永远的孩子。    </p></blockquote><p>&emsp;真巧，李志这首《妈妈》也在其中，对伴奏进行了些许改变，试听了一下，这首歌的伴奏是这几个版本中是我最喜欢的，也是我最害怕的，好像是有种束缚或者规则，限制了人越喜欢的东西越害怕失去，害怕损坏，害怕别人知道，害怕得不到….害怕去听。整首歌给我的感觉是 太多太多的消极，负面情绪如海啸袭来将你淹没，将你的身子冲刷在海底。扫了扫留言看到一条很真实很特别的评论</p><blockquote><p>昨晚叁叁肆汉中场，逼哥唱这首歌时，那句”你的孩子一直很乖”唱成了”你的孩子一直很怪”,当时在现场的我真的是止不住的掉。妈妈，”你的孩子一直很怪”</p></blockquote><p>&emsp;好奇点头像进去，翻了翻您的动态，又看到一条特别的动态，静悄悄地留了一句 “蒲公英和炊烟都在等你”。接着在自己动态里分享了这首歌，也留下了一句——“2019 1.14 5:10”。</p><h2 id="您的孩子一直很乖"><a href="#您的孩子一直很乖" class="headerlink" title="您的孩子一直很乖"></a>您的孩子一直很乖</h2><blockquote><p>写歌的人最无情，听歌的人假正经    </p></blockquote><p>&emsp;最害怕忽然听懂一首歌，看懂一本书，明白一个道理。就像李宗盛的歌写道“春风再美也比不上你的笑，没见过你的人不会明了”,有时候明了的人真明了，不明了的人永远也不会明了。</p><p>&emsp;记录到这，不想在记录了，因为已经凌晨四点了，该睡了明天还要”“噢！不 是今天”——还要继续过着充实且有趣的生活。<br>&emsp;我相信在每个夜晚，歌里面会告诉我一切。  </p><p>&emsp;收到网易云通知消息的时候，在此后的一分钟对您发了一句”真巧”。——“真巧”<br><img src="http://image.thorns.cn/qiao.jpeg" alt="avatar"></p><h1 id="您的孩子一直很怪"><a href="#您的孩子一直很怪" class="headerlink" title="您的孩子一直很怪"></a>您的孩子一直很怪</h1><p>蒲公英和炊烟都在等你<br>您的孩子一直很乖<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;——于2019 1.19 4:27</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;蒲公英和炊烟都在等你&quot;&gt;&lt;a href=&quot;#蒲公英和炊烟都在等你&quot; class=&quot;headerlink&quot; title=&quot;蒲公英和炊烟都在等你&quot;&gt;&lt;/a&gt;蒲公英和炊烟都在等你&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;蒲公英和炊烟都在等你，你的孩子一直很乖  &lt;/p&gt;
      
    
    </summary>
    
      <category term="李志" scheme="https://thorns.cn/categories/%E6%9D%8E%E5%BF%97/"/>
    
    
  </entry>
  
  <entry>
    <title>String to Integer</title>
    <link href="https://thorns.cn/2019/01/07/String%20to%20Integer.html"/>
    <id>https://thorns.cn/2019/01/07/String to Integer.html</id>
    <published>2019-01-07T13:47:47.000Z</published>
    <updated>2019-01-08T07:44:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="String-to-Integer-atoi"><a href="#String-to-Integer-atoi" class="headerlink" title=" String to Integer(atoi) "></a><font face="Calibri" size="6"> String to Integer(atoi) </font></h1><h2 id="原题描述"><a href="#原题描述" class="headerlink" title="原题描述"></a>原题描述</h2><blockquote><p>Implement atoi which converts a string to an integer.<br>实现c语言中的atoi函数,将string类型转化成int</p></blockquote><p>实现时需要考虑的因素有:  </p><ol><li>溢出问题  </li><li>输入无效</li><li>丢弃所有空格</li><li>数字正负号</li></ol><p>关于溢出，对于像我这种记不清楚int32范围的人，可以直接用long long类型解决。<br>数字正负号可以使用一个标志位进行标识，代码如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">int myAtoi(string str)</span><br><span class="line">&#123;</span><br><span class="line">    int flag = 0,pos = 0;</span><br><span class="line">    long long number = 0;</span><br><span class="line">    </span><br><span class="line">    //丢弃前面的空白字符串</span><br><span class="line">    while (str[pos] == &apos; &apos;) </span><br><span class="line">        pos++;</span><br><span class="line">    //判断正负号,下标移到符号下一位</span><br><span class="line">    if (str[pos] == &apos;-&apos; || str[pos] == &apos;+&apos;)</span><br><span class="line">        flag = str[pos++] == &apos;-&apos; ? -1:1;</span><br><span class="line">    </span><br><span class="line">    while (str[pos] &gt;= &apos;0&apos; &amp;&amp; str[pos] &lt;= &apos;9&apos;) &#123;</span><br><span class="line">        number = 10 * number + (str[pos++]-&apos;0&apos;);</span><br><span class="line">        //判断是否超过int32的范围</span><br><span class="line">        if (number &gt;INT_MAX)</span><br><span class="line">            return flag == 1 ? INT_MAX:INT_MIN;</span><br><span class="line">    &#125;</span><br><span class="line">    return (int)(number * flag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;String-to-Integer-atoi&quot;&gt;&lt;a href=&quot;#String-to-Integer-atoi&quot; class=&quot;headerlink&quot; title=&quot; String to Integer(atoi) &quot;&gt;&lt;/a&gt;&lt;font face=&quot;Calib
      
    
    </summary>
    
      <category term="leetcode" scheme="https://thorns.cn/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Reverse interger</title>
    <link href="https://thorns.cn/2019/01/06/Reverse%20interger.html"/>
    <id>https://thorns.cn/2019/01/06/Reverse interger.html</id>
    <published>2019-01-05T17:47:47.000Z</published>
    <updated>2019-01-08T07:53:10.457Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Reverse-interger"><a href="#Reverse-interger" class="headerlink" title="Reverse interger"></a>Reverse interger</h1><p>将一个整数反转，需要考虑溢出。<br>leetcode 原题链接：<a href="https://leetcode.com/problems/reverse-integer/" target="_blank" rel="noopener">https://leetcode.com/problems/reverse-integer/</a><br>example: x=123,return 321<br>example: x=-123,return -321<br>此题难度easy，不过需要考虑的是反转之后溢出情况。int32的范围-2147483648,2147483647。直接贴代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int reverse(int x)</span><br><span class="line">&#123;</span><br><span class="line">    int res = 0;</span><br><span class="line">    while (x != 0) &#123;</span><br><span class="line">        //判断是否溢出</span><br><span class="line">        if (abs(res) &gt; INT_MAX/10)</span><br><span class="line">            return 0;</span><br><span class="line">        res = res *10 + x % 10;</span><br><span class="line">        x /= 10;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当然也可以定义一个long long类型的变量，如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//解法2</span><br><span class="line">int reverse(int x)</span><br><span class="line">&#123;</span><br><span class="line">    long long res=0;</span><br><span class="line">    while (x != 0) &#123;</span><br><span class="line">        res = res *10 + x % 10;</span><br><span class="line">        x /= 10;</span><br><span class="line">    &#125;</span><br><span class="line">    //判断溢出</span><br><span class="line">    return (res&gt;INT_MAX||res&lt;INT_MIN)?0:res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>解法一，是直接判断是否大于INT_MAX/10(即214748364)，当res&gt;214748364时，必定溢出。因为x的第一位只能是1或者2，所以再执行res=res*10+x/10就会溢出。<br>解法二，直接定义了一个long long类型，最后判断是否大于INT_MAX或者小于INT_MIN。个人推荐解法一。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Reverse-interger&quot;&gt;&lt;a href=&quot;#Reverse-interger&quot; class=&quot;headerlink&quot; title=&quot;Reverse interger&quot;&gt;&lt;/a&gt;Reverse interger&lt;/h1&gt;&lt;p&gt;将一个整数反转，需要考虑溢出
      
    
    </summary>
    
      <category term="leetcode" scheme="https://thorns.cn/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>2018年度个人终结</title>
    <link href="https://thorns.cn/2018/12/28/2018%E5%B9%B4%E5%BA%A6%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93.html"/>
    <id>https://thorns.cn/2018/12/28/2018年度个人总结.html</id>
    <published>2018-12-27T17:47:47.000Z</published>
    <updated>2019-03-15T13:22:30.847Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一转眼就是年底，不知不觉这已经是出来工作的第四个年头了。回望过去，感觉还是那个刀未佩妥已身在江湖的少年郎了。一切都太匆匆，希望在这节奏快的时代，有一篇文章能承载着在路上的味道。</p></blockquote><h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>&emsp;年初找到了一份自己喜欢，前景不错的工作，并且薪资也达到了理想的目标。了解了许多以前未接触的领域，有技术上的 区块链开发，duilib的界面开发，也有非技术上的，炒币 、期货 、外汇。</p><h3 id="缺点与不足"><a href="#缺点与不足" class="headerlink" title="缺点与不足"></a>缺点与不足</h3><p>&emsp;1.也许是一个人达到了心理的预期都会有一个放空期，下半年明显感觉自己在工作上，和对技术上都出现了严重的慵懒，复杂的不愿意去做，需要大量时间成本的不愿意去学习。  </p><p>&emsp;2.工作上的沟通交流明显不足，需要多锻炼沟通交流能力。好的交流能力能有效的突出自我，以及发现别人好的idea，审视自己的不足。  </p><p>&emsp;3.英文太差，英文不好的不一定是大佬，英文好的一定是大佬。在看文档时，去靠google翻译太耗时，需要提升英文能力。</p><h3 id="计划与改善"><a href="#计划与改善" class="headerlink" title="计划与改善"></a>计划与改善</h3><p>&emsp;1.多看优秀的源码与书籍，与学习。</p><blockquote><p>看redis,telegram,libevent实现，读《深度探索C++对象模型》,《Windows核心编程》,《Python3爬虫》，学习boost，muduo,spark,kafka。  </p></blockquote><p>&emsp;2.提高英文水平，储备词汇量，英文技术文档时尽量自己翻译。<br>&emsp;3.积极与同事沟通交流，多参加线下的技术交流会。</p><h3 id="工作总结"><a href="#工作总结" class="headerlink" title="工作总结"></a>工作总结</h3><p>&emsp;这一年里自我评价提升很快，个人认为跟工作环境以及公司团队的一个良好气氛是离不开的，对比去年由于个人沟通交流能力薄弱，工作上有许多地方没能跟上级及时沟通，不仅导致公司产品开发进度且自己也没能得到一个好的提升，在这里要感谢现在的领导和公司，得以借助他们良好的沟通能力和好的平台，让我在工作中不断的学习、提升、进步。谢谢您们！<br>工作上接触的知识面很多，当然也加了不少班，熬了不少夜。技术面相比较以前广度多了不少，如区块链，钱包，交易所等这些都是曾经未接触，随之而来的缺点就是深度不够。有很多原理、底层、框架的东西都不太明白，真正要用的时候不能信手拈来，出错时也只能靠google救场。在这里需要多看源码，多去深入学习好的架构和设计思想。</p><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>生活上这一年要比去年过得有趣精致一点，从以前不能忍受合租到合租再到现在的独居，虽然房租贵了很多，但是值得的。想看书时，再也听不到打游戏的声音，想播放自己喜欢的音乐时，再也没有其它的歌声扰乱自己。一个人安安静静做着喜欢的事，听着喜欢的歌，美哉！偶尔周末也会自己做做饭，爬爬山，去参加技术沙龙，听听喜欢的歌手的livehouse。 </p><p>生活上由于理财意识不高，月光，导致过了一段比较拮据的时光，不过挺感谢这段时光，也让我经历了一段旁人未经历过的风景。一个人的生活最大的缺点就是作息不规律，晚上经常熬夜，吃饭不规律，饮食习惯不好，这些希望能在后面的时间日渐改善。</p><h3 id="缺点与不足-1"><a href="#缺点与不足-1" class="headerlink" title="缺点与不足"></a>缺点与不足</h3><p>&emsp;1.生活作息时间和饮食习惯极其不好<br>&emsp;2.生活很慵懒，尤其是下半年周末很少出去走动<br>&emsp;3.理财意识不高，典型月光族一枚</p><h3 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h3><p>&emsp;1.加强理财意识，物质基础决定上层建筑<br>&emsp;2.生活作息规律，培养一个好的饮食习惯（胃）</p><h2 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h2><p>2018读过的书:<br>《雨季不再来》<br>《送你一匹马》<br>《万水千山走遍》<br>《云去云来》<br>《窗里窗外》<br>《白夜行》<br>《人间失格》<br>《黄金时代》<br>《浪潮之巅》<br>《Effective C++》  </p><p>阅读量太少了，一年十本书都未到…很羞愧，在来年需要提高阅读量，少读无内容的书籍，学习是整个人生最有意义的事情。</p><h2 id="电影"><a href="#电影" class="headerlink" title="电影"></a>电影</h2><p>18年印象深刻的电影:<br>对于电影，平时看的少，所以只能慢慢追以前比较经典的电影。  </p><p>《重庆森林》&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;——“今天他喜欢凤梨，明天他可以喜欢别的”<br>《蝴蝶效应》&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;——“即使细微如蝴蝶鼓舞，也能煽动千里之飓风”<br>《海上钢琴师》&ensp;&ensp;&ensp;&ensp;&ensp; ——“fuck the regulations”<br>《泰坦尼克号》&ensp;&ensp;&ensp;&ensp;&ensp; ——“Can I take your name,please,love? Dawson.Rose Dawson”<br>《海边的曼彻斯特》&ensp;&ensp;——“I cann’t beat it”    </p><h2 id="2018实现的目标"><a href="#2018实现的目标" class="headerlink" title="2018实现的目标"></a>2018实现的目标</h2><p>1.找到一份金融行业 且团队气氛不错 薪资到达个人目标<br>2.换一台mbp<br>3.租一间自己满意的小窝<br>4.去听李志的现场<br>5.去听陈粒的现场<br>5.去香港旅游一次<br>6.去南京旅游一次</p><h2 id="2018未实现的目标"><a href="#2018未实现的目标" class="headerlink" title="2018未实现的目标"></a>2018未实现的目标</h2><p>1.存款未到  (写到这里，一两点光着身子的我瑟瑟发抖)<br>2.阅读书籍量未到10本<br>3.英文词汇量未到<br>4.出国旅行跳伞未到<br>5.杰伦的现场未到    (事出有因，可恨的黄牛！！)<br>6.冠希的现场未到    </p><h2 id="2019目标"><a href="#2019目标" class="headerlink" title="2019目标"></a>2019目标</h2><p>1.通过不断学习，技术上能得到一个质的提升<br>2.培养一门业余技能<br>3.提高理财意识，存款到达心中的目标<br>4.阅读累计20本书<br>5.坚持两周写一篇博客<br>6.提升自己学历<br>7.芭提雅跳伞<br>8.西藏骑行<br>9.去听叁叁肆现场一次<br>10.体验不回家过年<br>11.做五件有意义的事情</p><p>End</p><blockquote><p>“成为自己想成为的人，做自己想做的事。即使失败了，也可以重新再来”<br>别怕失败，大不了从头来过，你懂的！          ——陈冠希  </p></blockquote><p>最后附一张冠希的图以激励自己。<br><img src="http://image.thorns.cn/edc.jpeg" alt="avatar"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;一转眼就是年底，不知不觉这已经是出来工作的第四个年头了。回望过去，感觉还是那个刀未佩妥已身在江湖的少年郎了。一切都太匆匆，希望在这节奏快的时代，有一篇文章能承载着在路上的味道。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;工作&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="Life" scheme="https://thorns.cn/categories/Life/"/>
    
    
  </entry>
  
  <entry>
    <title>这么多年你一个人 一直在走</title>
    <link href="https://thorns.cn/2018/12/09/1208.html"/>
    <id>https://thorns.cn/2018/12/09/1208.html</id>
    <published>2018-12-09T03:21:40.000Z</published>
    <updated>2019-07-15T02:57:28.955Z</updated>
    
    <content type="html"><![CDATA[<h1 id="这么多年你一个人-一直在走"><a href="#这么多年你一个人-一直在走" class="headerlink" title="这么多年你一个人 一直在走"></a>这么多年你一个人 一直在走</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>恩，昨天某个逼让我失了声感冒了。中午起床极度不爽，得以于此，借深圳余温未散抽空记录一下生活。  </p></blockquote><p>&emsp;听他的歌时间不长，不到一年。忘记了从哪首开始，也不知道该在哪首结束。<br>&emsp;记忆中应该是在知晓了“祝星”这号人物的时候，才知道了“港岛妹妹”的西班牙馅饼。那段时间酷爱三毛笔下的西班牙，撒哈拉。也因此喜欢上了陈粒的《历历万乡》。不同于其它人对“港岛妹妹”的幻想，对“西班牙馅饼”的期待，我了解的“港岛妹妹”不过是某装逼犯的自淫，“西班牙馅饼”也不过是一张明信片。  </p><h2 id="你说你遇见了一大堆奇怪的人"><a href="#你说你遇见了一大堆奇怪的人" class="headerlink" title="你说你遇见了一大堆奇怪的人"></a>你说你遇见了一大堆奇怪的人</h2><p>&emsp;时光就这样悄悄的流走，早高峰 晚高峰，有身穿OL装的白领正拿着粉底盒涂抹着她那疲惫的妆容，有一张张放声大笑的脸努力汲取着手机上短视频的笑点，也有戴着耳机或是手拿一部kindle为考研，为四六级而准备的人群……像是厌倦了一切变得麻木，低头听歌，听歌抬头，抬头下车。忽然在某一早晨，耳边隐约回响起一句“这么多年你一个人，一直在走，你说你遇见了一大堆奇怪的人，他们看上去好像都比你开心。”至此我明白，在那一座六朝古都，那座为一人种满了梧桐的城市，有一个独立的灵魂用它那低沉，嘶吼的声音在我耳边激荡盘旋，不能离去。从此，喜欢李志的歌一发不可收拾。</p><h2 id="他们指向左，他们指向右"><a href="#他们指向左，他们指向右" class="headerlink" title="他们指向左，他们指向右"></a>他们指向左，他们指向右</h2><p>&emsp;有人说不能常听他的歌，会变得浑身充满负能量的人。对于这种说法，我身边的一位朋友，告诉我他“每天都是靠这逼的歌坚持下去的”，他的歌充满意义，带有思考。哈哈哈，写在这里的时候，真…<br>关于这首歌还是不提为好。有想研究的自个研究去。  </p><p><img src="/images/李志.jpeg" alt="avatar"></p><a id="more"></a><h2 id="这个世界会好的"><a href="#这个世界会好的" class="headerlink" title="这个世界会好的"></a>这个世界会好的</h2><p>昨天他的压轴，一出场全场齐呼“逼哥牛逼，逼哥牛逼”！第一眼看到真人，一顶老旧的灰色帽子，一件老旧的灰色短袖(出发的时候朋友叫我带衣服，嫌麻烦没带，这两天深圳满30减15的温度活动不得不说很商业化，但看到他穿着一件短袖，“牛逼”！),一条老旧的蓝色牛仔，跟每天在视频上看到的并无差别。跟上面的图片搭配一模一样，心中不禁想这套衣服多久没换了？还好牙齿洗了。旁边的一位，额 怎么来形容呢，对于年龄比自己的大的吧 叫一声美女显得轻浮，说叫一个女人吧显得又太不会用词。那就叫旁边的一位可爱的女孩吧。《逃避可耻却有用》里面讲“可爱是最高级的形容词”，说的真对。一直在哪欢呼，在台底下跟逼哥抬扛，逼哥唱到“妈妈”的时候，她吼“恩，我在这里”，说到“一根烟的时候”，她回“是两根”，很喜欢这种氛围。全程一个小时下来，逼哥在结束开启了他的逼言逼语，后面的旗子挥舞着一个”B”字。他讲40年来改革开放，讲我们应该要谢谢，要学会感恩。嗯，这个世界会好的。</p><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>他就是b言b语，五块钱的发型，老套的衣服，一口大黄牙。却让人不反感，你知道他开始装逼了，听完了。你甚至都想去买两包南京(九五之尊)给他点着，既然这次没机会给你散烟，那就劳驾我拉着我的基友亲自去热河给你散一根南京的南京吧。   </p><p>朋友对我刁侃道:你走在宋美龄大道上风花雪月，我走在义和五龙街感叹人生  </p><p>我回:不是因为六朝古都，不是因为哪座种满了梧桐的城市。<br>我带你去南京听热河，带你去武林门听杭州。<br>自带装逼属性有没有！<br><img src="/images/1.jpeg" alt="avatar"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;这么多年你一个人-一直在走&quot;&gt;&lt;a href=&quot;#这么多年你一个人-一直在走&quot; class=&quot;headerlink&quot; title=&quot;这么多年你一个人 一直在走&quot;&gt;&lt;/a&gt;这么多年你一个人 一直在走&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;恩，昨天某个逼让我失了声感冒了。中午起床极度不爽，得以于此，借深圳余温未散抽空记录一下生活。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;emsp;听他的歌时间不长，不到一年。忘记了从哪首开始，也不知道该在哪首结束。&lt;br&gt;&amp;emsp;记忆中应该是在知晓了“祝星”这号人物的时候，才知道了“港岛妹妹”的西班牙馅饼。那段时间酷爱三毛笔下的西班牙，撒哈拉。也因此喜欢上了陈粒的《历历万乡》。不同于其它人对“港岛妹妹”的幻想，对“西班牙馅饼”的期待，我了解的“港岛妹妹”不过是某装逼犯的自淫，“西班牙馅饼”也不过是一张明信片。  &lt;/p&gt;
&lt;h2 id=&quot;你说你遇见了一大堆奇怪的人&quot;&gt;&lt;a href=&quot;#你说你遇见了一大堆奇怪的人&quot; class=&quot;headerlink&quot; title=&quot;你说你遇见了一大堆奇怪的人&quot;&gt;&lt;/a&gt;你说你遇见了一大堆奇怪的人&lt;/h2&gt;&lt;p&gt;&amp;emsp;时光就这样悄悄的流走，早高峰 晚高峰，有身穿OL装的白领正拿着粉底盒涂抹着她那疲惫的妆容，有一张张放声大笑的脸努力汲取着手机上短视频的笑点，也有戴着耳机或是手拿一部kindle为考研，为四六级而准备的人群……像是厌倦了一切变得麻木，低头听歌，听歌抬头，抬头下车。忽然在某一早晨，耳边隐约回响起一句“这么多年你一个人，一直在走，你说你遇见了一大堆奇怪的人，他们看上去好像都比你开心。”至此我明白，在那一座六朝古都，那座为一人种满了梧桐的城市，有一个独立的灵魂用它那低沉，嘶吼的声音在我耳边激荡盘旋，不能离去。从此，喜欢李志的歌一发不可收拾。&lt;/p&gt;
&lt;h2 id=&quot;他们指向左，他们指向右&quot;&gt;&lt;a href=&quot;#他们指向左，他们指向右&quot; class=&quot;headerlink&quot; title=&quot;他们指向左，他们指向右&quot;&gt;&lt;/a&gt;他们指向左，他们指向右&lt;/h2&gt;&lt;p&gt;&amp;emsp;有人说不能常听他的歌，会变得浑身充满负能量的人。对于这种说法，我身边的一位朋友，告诉我他“每天都是靠这逼的歌坚持下去的”，他的歌充满意义，带有思考。哈哈哈，写在这里的时候，真…&lt;br&gt;关于这首歌还是不提为好。有想研究的自个研究去。  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/李志.jpeg&quot; alt=&quot;avatar&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="李志" scheme="https://thorns.cn/categories/%E6%9D%8E%E5%BF%97/"/>
    
    
  </entry>
  
  <entry>
    <title>traits编程技法</title>
    <link href="https://thorns.cn/2018/08/31/traits%E7%BC%96%E7%A8%8B%E6%8A%80%E6%B3%95.html"/>
    <id>https://thorns.cn/2018/08/31/traits编程技法.html</id>
    <published>2018-08-31T04:06:20.000Z</published>
    <updated>2018-08-30T16:10:17.468Z</updated>
    
    <content type="html"><![CDATA[<h1 id="STL之traits编程技法的理解"><a href="#STL之traits编程技法的理解" class="headerlink" title="STL之traits编程技法的理解"></a>STL之traits编程技法的理解</h1><blockquote><p>注:很多内容节选自《STL源码剖析》,见上自己的理解，特此记录   </p></blockquote><ul><li>traits又被叫做”特性萃取技术”,用于提取被”被传进来的对象对应的返回类型,让同一个接口实现对应的功能。因为STL的算法和容器是分离的,两者通过迭代器连接,算法的实现并不知道传进来的是什么,萃取器相当于接口和实现之间加一层封装,来隐藏一些细节并协助调用合适的方法。<h2 id="迭代器的类型"><a href="#迭代器的类型" class="headerlink" title="迭代器的类型"></a>迭代器的类型</h2>我们知道迭代器有五种类型,分别是    </li></ul><ol><li>value_type(迭代器所指对象的类型)</li><li>difference_type(用来表示两个迭代器之间的距离)</li><li>reference_type(迭代器所指对象的引用)</li><li>point_type(迭代器所指的对象)</li><li>iterator_category(标识迭代器的移动特性和可以对迭代器进行的操作,大致可以分为五类)<br> Input iterator<br> Output iterator<br> Forward iterator<br> Bidirectional iterator<br> Random Access iterator     </li></ol><h2 id="声明内嵌型别"><a href="#声明内嵌型别" class="headerlink" title="声明内嵌型别"></a>声明内嵌型别</h2><p>考虑一下，当我们需要实现某个函数时,且该函数的返回类型必须是value_type是，该怎么办？我们不能使用”template 参数推导机制”,毕竟推导机制推导的是参数，无法推导函数的返回值型别。<br>在这里我们就可以用到声明内嵌型别,来解决使用value_type用于函数的返回类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class T&gt;</span><br><span class="line">struct MyIter&#123;</span><br><span class="line">  typedef T value_type;     //内嵌型别声明</span><br><span class="line">  MyIter(T *p=0):ptr(p) &#123;&#125;</span><br><span class="line">  T&amp; operator*() const &#123;return *ptr;&#125;</span><br><span class="line">  private:</span><br><span class="line">    T *ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//使用value_type用于函数返回类型</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">typename I::value_type func(I ite)</span><br><span class="line">&#123;</span><br><span class="line">    return *ite;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//...</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Myiter&lt;int&gt; ite(new int(8));</span><br><span class="line">    cout&lt;&lt;func(ite)&lt;&lt;endl;  //输出:8</span><br><span class="line">&#125;</span><br><span class="line">```   </span><br><span class="line">func函数中的typename用意是在告诉编译器I::value_type是一个型别,因为T是一个template参数,在它被编译器具现化之前,编译器对T一无所悉,编译器不知道I::value_type代表的是一个型别还是一个member function或者是data member。   </span><br><span class="line">这样看起来结局了我们的问题,但是有个隐晦的陷阱:并不是所有的迭代器都是class type。原生指针就不是,如果不是class type,就无法为它定义内嵌型别。有没有好的解决办法呢？偏特化可以为我们解决这个问题。</span><br><span class="line">## 模板偏特化</span><br><span class="line">《STL源码剖析》一书上对模板偏特化的意义大致解释是:</span><br><span class="line">&gt; 如果class template拥有一个以上的template参数,我们可以针对其中某个(或数个,但非全部)template参数进行特化工作。换句话说,我们可以在泛化设计中提供一个特化版本。</span><br></pre></td></tr></table></figure></p><p>//萃取器<br>template <class i=""><br>struct iterator_traits{<br>  typedef typename T I::value_type value_type;<br>};</class></p><p>//偏特化版<br>template <class t=""><br>struct ierator_traits&lt;T*&gt;{<br>  typedef T value_type;<br>};</class></p><p>//偏特化过后的func函数<br>template <class t=""><br>typename iterator_traits<i>::value_type //这一整行是函数返回型别<br>func(I ite)<br>{<br>    return *ite;<br>}</i></class></p><p>int main()<br>{<br>    int a=8;<br>    int <em>p=&a;<br>    cout&lt;&lt;func(p)&lt;&lt;endl;    //传的类型是int</em><br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">上面我们通过偏特化版就可以获取原始指针的型别用来定义函数返回型别,可能会问如果原始指针是个pointer-to-const怎么办呢？没关系再偏特化一个版本就好了</span><br></pre></td></tr></table></figure><p>template <class t=""><br>struct iterator_traits<const t*="">{<br>  typedef T value_type;<br>};<br><code>`</code><br>以上就是stl中使用的traits技法，traits就像一台”特性萃取机”,萃取各个迭代器的相应型别。</const></class></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;STL之traits编程技法的理解&quot;&gt;&lt;a href=&quot;#STL之traits编程技法的理解&quot; class=&quot;headerlink&quot; title=&quot;STL之traits编程技法的理解&quot;&gt;&lt;/a&gt;STL之traits编程技法的理解&lt;/h1&gt;&lt;blockquote&gt;

      
    
    </summary>
    
      <category term="STL源码剖析" scheme="https://thorns.cn/categories/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
    
      <category term="STL traits" scheme="https://thorns.cn/tags/STL-traits/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu安装Mongodb及配置</title>
    <link href="https://thorns.cn/2018/08/23/ubuntu%E5%AE%89%E8%A3%85Mongodb%E5%8F%8A%E9%85%8D%E7%BD%AE.html"/>
    <id>https://thorns.cn/2018/08/23/ubuntu安装Mongodb及配置.html</id>
    <published>2018-08-23T02:58:20.000Z</published>
    <updated>2018-08-24T04:10:58.680Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ubuntu安装Mongodb及配置"><a href="#ubuntu安装Mongodb及配置" class="headerlink" title="ubuntu安装Mongodb及配置"></a>ubuntu安装Mongodb及配置</h1><p>官方下载地址: <a href="https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-amazon2-4.0.1.tgz" target="_blank" rel="noopener">https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-amazon2-4.0.1.tgz</a>  </p><p>使用curl进行下载<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -O https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-amazon2-4.0.1.tgz</span><br></pre></td></tr></table></figure></p><p>解压<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf mongodb-linux-x86_64-ubuntu1404-4.0.1.tgz</span><br></pre></td></tr></table></figure></p><p>移动到用户local目录下(可自定义)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mv mongodb-linux-x86_64-ubuntu1404-4.0.1.tgz /usr/local/mongodb</span><br></pre></td></tr></table></figure></p><p>创建数据库目录和日志目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /data/db</span><br><span class="line">sudo mkdir /data/logs</span><br></pre></td></tr></table></figure></p><p>创建配置文件,启动mongod时需要<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/local/mongodb/bin/mongodb.conf #将配置文件放在mongodb/bin目录下</span><br><span class="line"></span><br><span class="line">dbpath=/data/db/    #db路径</span><br><span class="line">logpath=/data/logs/mongodb.log  #log路径</span><br><span class="line">fork=true   #以后台模式mongos进程  </span><br><span class="line">port=27017</span><br></pre></td></tr></table></figure></p><p>配置mongodb环境变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bashrc</span><br><span class="line">#在最后添加</span><br><span class="line">export PATH=$PATH:/usr/local/mongodb/bin</span><br><span class="line">#退出使用source命令使设置生效</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure></p><p>接下来就可以开启mongodb服务了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mongod -f /usr/local/mongodb/bin/mongodb.conf</span><br><span class="line">#使用mongo连接服务</span><br><span class="line">mongo</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ubuntu安装Mongodb及配置&quot;&gt;&lt;a href=&quot;#ubuntu安装Mongodb及配置&quot; class=&quot;headerlink&quot; title=&quot;ubuntu安装Mongodb及配置&quot;&gt;&lt;/a&gt;ubuntu安装Mongodb及配置&lt;/h1&gt;&lt;p&gt;官方下载地址
      
    
    </summary>
    
      <category term="Mongodb" scheme="https://thorns.cn/categories/Mongodb/"/>
    
    
      <category term="Mongodb" scheme="https://thorns.cn/tags/Mongodb/"/>
    
  </entry>
  
  <entry>
    <title>谈谈ss和socks5协议</title>
    <link href="https://thorns.cn/2018/05/06/%E8%B0%88%E8%B0%88socks5%E5%8D%8F%E8%AE%AE%E5%92%8Css.html"/>
    <id>https://thorns.cn/2018/05/06/谈谈socks5协议和ss.html</id>
    <published>2018-05-06T08:12:32.000Z</published>
    <updated>2018-05-06T08:20:28.008Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ss和socks5协议"><a href="#ss和socks5协议" class="headerlink" title="ss和socks5协议"></a>ss和socks5协议</h1><blockquote><p>本文首发于个人博客:<a href="http://www.thorns.cn" target="_blank" rel="noopener">www.thorns.cn</a></p></blockquote><p>前言:由于最近公司需要一个自己的代理服务,所以花了一周的时间去研究了下shadowsocks实现的原理,以及socks5协议。</p><h1 id="认识Shadowsocks"><a href="#认识Shadowsocks" class="headerlink" title="认识Shadowsocks"></a>认识Shadowsocks</h1><p>Shadowsocks是一个能骗过GFW的网络代理工具,它把我们要访问的数据请求,比如google,youtube，facebook…进行加密后传输到GFW外的服务端,由服务端去访问目标站点再加密返回给我们,网络中的GFW由于不知道传输的原内容是什么只好放行,于是就完成了我们所谓的”翻墙”。  </p><h1 id="Shadowsocks原理"><a href="#Shadowsocks原理" class="headerlink" title="Shadowsocks原理"></a>Shadowsocks原理</h1><p>SS(Shadowsocks)由两部分组成,运行在本地的ss-local和防火墙之外服务器上的ss-server。ss-local的职责是在本机启动和监听一个服务,本地软件的网络请求都会先发送到ss-local,ss-local收到来自本地软件的网络请求后,把要传输的原数据根据用户配置的加密方法和密码进行加密,再转发到服务端。ss-server的职责是在墙外服务器启动和监听一个服务,当服务端收到ss-local转发过来的数据时,会根据用户配置的加密方法和密码对数据进行解密,同时还会解socks5协议，然后会把解密后的数据转发到真正的请求目标服务地址(例如Google),以下是整个流程图.<br><img src="/images/liucheng.png" alt="avatar"></p><h1 id="Socks5协议介绍"><a href="#Socks5协议介绍" class="headerlink" title="Socks5协议介绍"></a>Socks5协议介绍</h1><p>SS的数据传输是建立在socks5协议之上的，Socks5是TCP/IP的网络代理协议，socks5有协商认证请求部分,个人更喜欢把他叫做Protocol Handshake。</p><h2 id="协商版本和验证方法"><a href="#协商版本和验证方法" class="headerlink" title="协商版本和验证方法"></a>协商版本和验证方法</h2><p>当我们的客户端向服务端建立连接之后,客户端就会向服务端进行协商,发送的数据包如下:<br><img src="/images/xs.png" alt="avatar"></p><p>其中各字段的含义如下:<br>VER:代表SOCKS的版本,SOCKS5 默认为0x05,固定长度一个字节。<br>NMETHODS:表示第三个字段的长度(也就是有几种认证方法),长度也是一个字节<br>METHODS:表示客户端支持的验证方式,可以有多种,长度1-255字节。<br>支持的验证方式有:  </p><ul><li>0x00:NO AUTHENTICATION REQUIRED（不需要验证）  </li><li>0x01:GSSAPI (通用安全服务应用程序接口)  </li><li>0x02:USERNAME/PASSWD(用户名密码)  </li><li>0x03:IANA ASSIGNED(至 0x’7F’ IANA 分配)</li><li>0x80:RESERVED FOR PRIVATE METHODS(至 0x’FE’ 私人方法保留)  </li><li>0xff:NO ACCEPTABLE METHODS(没有可接受的方法)<br>当服务端收到客户端的验证机信息之后，就要回应客户端提供哪种验证方式的信息。服务端回应的包格式如下:<br><img src="/images/xs1.png" alt="avatar"></li><li>VER:代表SOCKS的版本,SOCKS5默认为0x05,长度一个字节。  </li><li>METHOD:代表服务端回应客户端需要哪种验证方式,可以为上面六种验证方式之一   </li></ul><p>举个例子,比如客户端发送的包是 0x05 0x01 0x02，如果服务端不需要验证就会返回0X05 0X00,需要验证就会返回0x05 0x02,接下来客户端就需要进行认证这一步，也就是把用户名和密码发送给服务端进行认证,在这里我就不介绍认证这一步了,直接说请求这一步。</p><h2 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h2><p>客户端发起的连接由服务端验证通过后,客户端下一步就应该把要访问的目的网站地址给服务端,服务端得到地址后再去请求真正的目标服务。这一步客户端需要发送的包格式如下:<br><img src="/images/re.png" alt="avatar"></p><p>各个字段含义如下:</p><ul><li>VER:socks的版本  </li><li>CMD:代表客户端请求的类型，值长度1个字节,有三种类型:  <ol><li>Connect: 0x01  </li><li>BIND: 0x02</li><li>UDP: 0x03</li></ol></li><li>RSV:保留字段,默认0x00,长度1个字节</li><li>ATYP:代表请求的远程服务器地址类型,长度1个字节，三种类型:<ol><li>IPV4: 0x01</li><li>IPV6: 0x04</li><li>DOMAINNAME: 0x03</li></ol></li><li>DST.ADDR:代表远程服务器的地址,根据ATYP进行解析,值长度不定  </li><li>DST.PORT:代表远程服务器的端口,值长度2个字节</li></ul><p>服务端再收到客户端告诉的目标服务地址后，便和目标进行连接,不管成功与否,服务器都应该把连接的结果告诉客户端.如果连接成功的情况下,服务端返回的包格式如下:<br><img src="/images/sre.png" alt="avatar"></p><p>各个字段含义如下:</p><ul><li>REP:代表响应码,值长度1个字节，有如下类型<ol><li>0x00:succeeded(成功)</li><li>0x01:general SOCKS server failure(socks5服务器失败)</li><li>0x02:connection not allowed by ruleset</li><li>0x03:Network unreachable(网络无法访问)</li><li>0x04:Host unreachable(主机无法访问)</li><li>0x05:Connection refused(拒绝连接)</li><li>0x06:TTL expired(TTL 超时)</li><li>0x07:Command not supported(命令不支持)</li><li>0x08:Address type not supported(地址类型不受支持)</li><li>0x09:to 0xFF unassigned</li></ol></li><li>RSV:保留字,值长度一字节  </li><li>BND.ADDR:表示绑定地址,值长度不定  </li><li>BND.PORT:表示绑定端口,值长度2字节  </li></ul><h2 id="数据转发"><a href="#数据转发" class="headerlink" title="数据转发"></a>数据转发</h2><p>客户端在收到来自服务器成功的响应后，就会开始发送数据给本地代理，本地代理加密后进行转发给服务端,服务端解密之后访问最终目标服务。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>SOCKS5协议的目的就是为了把原本应该在本机直接请求目标服务的流程,放到了服务端去代理 客户端访问.运行流程如下:</p><p>本地代理和服务端协商认证请求<br>本地代理告诉服务端目标服务的地址<br>服务端去访问目标服务,成功后告诉本地代理<br>本机开始发送原本应发送到目标服务的数据给服务端,由服务端完成数据转发  </p><p>注:以上内容有很多部分都是参考RFC1928,和其他博主发表的博文，借鉴而来。如果感觉有什么地方不对或者不同见解的，都可以提出争议,以立即改正。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ss和socks5协议&quot;&gt;&lt;a href=&quot;#ss和socks5协议&quot; class=&quot;headerlink&quot; title=&quot;ss和socks5协议&quot;&gt;&lt;/a&gt;ss和socks5协议&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本文首发于个人博客:&lt;a href=&quot;ht
      
    
    </summary>
    
      <category term="网络编程" scheme="https://thorns.cn/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="socks" scheme="https://thorns.cn/tags/socks/"/>
    
  </entry>
  
  <entry>
    <title>More Effective C++ 8:new和delete</title>
    <link href="https://thorns.cn/2018/05/03/new.html"/>
    <id>https://thorns.cn/2018/05/03/new.html</id>
    <published>2018-05-02T20:04:44.000Z</published>
    <updated>2018-12-09T05:30:05.040Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>最近在看侯捷译的More Effective C++,看的过程有不少收获,发现自己对C++很多地方其实没有过多去了解,收获很多,记录一下。</p></blockquote><h1 id="三种new和delete"><a href="#三种new和delete" class="headerlink" title="三种new和delete"></a>三种new和delete</h1><p>我们知道,new和delete都是C++里的关键字,同时也是操作符。new负责分配内存，delete释放内存。new和delete都有new operator、operator new，placement new，delete operator。下面分别介绍这几种操作</p><h2 id="new-operator和delete-operator"><a href="#new-operator和delete-operator" class="headerlink" title="new operator和delete operator"></a>new operator和delete operator</h2><p>new operator和delete operator就是我们经常使用的new和delete,这两个操作符是由语言内建的,就像sizeof操作符一样，不能被改变意义。当我们写出这样的代码时new operatorf和new delete在执行时分为两步:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string *ps=new string(&quot;new operator&quot;);</span><br><span class="line">delete ps;</span><br></pre></td></tr></table></figure><ol><li>new operator 会先执行分配内存的操作,它会调用一个只分配内存的函数,这个函数就是operator new,它分配足够的内存，用来放置对象。new delete在释放内存前，会先调用对象的析构函数.</li><li>当new operator分配完内存的时候,它会调用一个构造函数,为刚才分配的内存中的对象设定初值。而delete operator调用完析构函数时,它会调用一个释放内存的函数 operator delete,这时候才会释放对象所占用的内存。</li></ol><p>以上两行代码，拆分开来就是这样,先调用构造函数,分配内存，调用析构函数，释放内存,在编译器中的操作如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void *memory=operator new(sizeof(string)); //取得原始内存</span><br><span class="line">call string::string(&quot;Memory Management&quot;) on*memory;//将内存中的对象初始化</span><br><span class="line">string *ps=static_cast&lt;string*&gt;(memory)；</span><br></pre></td></tr></table></figure><ul><li>注意new operator 和new delete都不可以被重载。</li></ul><h2 id="operator-new和operator-delete"><a href="#operator-new和operator-delete" class="headerlink" title="operator new和operator delete"></a>operator new和operator delete</h2><p>上面一直说到new和delete其实在内部都会调用到这两个函数，这两个函数到底跟new和delete有什么区别呢？通常operator new ,operator delete声明如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void *ps=operator new(sizeof(string));</span><br><span class="line">operator delete(ps);</span><br></pre></td></tr></table></figure><h2 id="placement-new-定位new"><a href="#placement-new-定位new" class="headerlink" title="placement new(定位new)"></a>placement new(定位new)</h2><blockquote><p>写这篇文章,其实主要是写这个用法，还记得看到这个用法的时候，是在侯捷翻译的另一本书《STL 源码剖析》在讲空间配置器时看见的。</p></blockquote><p>placement new是operator new的一种特殊版本,也是new operator的另一种用法,在已分配的内存上构造对象。要使用placement new必须要包含头文件new,#include或者#include&lt;new.h&gt;,调用示例就直接用书上的了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Widget</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Widget(int widgetSize);</span><br><span class="line">&#125;;</span><br><span class="line">Widget *constructWidgetInBuffer(void *buffer,int widgetSize)</span><br><span class="line">&#123;</span><br><span class="line">    return new(buffer) Widget(widgetSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此函数返回指针,指向一个Widget对象,它被构造于传递给此函数的一块内存缓冲区上。在函数内部唯一的表达式就是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new (buffer) Widget(widgetSize);</span><br></pre></td></tr></table></figure><p>于是,在buffer指向的这边空间，就构造了一个Widget对象。</p><p>注意,如果你使用了placement new，在某块内存中产生对象,应该避免对那块内存使用delete operator。因为这个delete operator会调用operator delete来释放内存,但是该内存内含的对象最初并非是由operator new分配得来的,毕竟placement new只是返回它所接受的指针而已,应该直接调用该对象的析构,然后在释放内存。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void *mallocShared(size_t size);</span><br><span class="line">void freeShared(void *memory);</span><br><span class="line">void *sharedMemory=mallocShared(sizeof(Widget));</span><br><span class="line">Widget *pw=constructWidgeInBuffer(sharedMemory,10);//placement new用法</span><br><span class="line">...</span><br><span class="line">delete pw;//错。sharedMemory来自mallocShared，不是来自operator new</span><br><span class="line">pw.~Widget();  //可以，析构pw所指的Widget对象,但并未释放Widget占用的内存</span><br><span class="line">freeShared(pw);  //可以,释放pw所指的内存,不调用任何析构函数</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;最近在看侯捷译的More Effective C++,看的过程有不少收获,发现自己对C++很多地方其实没有过多去了
      
    
    </summary>
    
      <category term="More Effective C++" scheme="https://thorns.cn/categories/More-Effective-C/"/>
    
    
      <category term="More Effective C++" scheme="https://thorns.cn/tags/More-Effective-C/"/>
    
  </entry>
  
  <entry>
    <title>Windows下编译libcurl和使用</title>
    <link href="https://thorns.cn/2018/04/01/Windows%E4%B8%8B%E7%BC%96%E8%AF%91libcurl.html"/>
    <id>https://thorns.cn/2018/04/01/Windows下编译libcurl.html</id>
    <published>2018-04-01T15:47:44.000Z</published>
    <updated>2018-05-06T07:38:54.864Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Windows下编译libcurl和使用"><a href="#Windows下编译libcurl和使用" class="headerlink" title="Windows下编译libcurl和使用"></a>Windows下编译libcurl和使用</h1><blockquote><p>之前在Linux下使用过wget和curl,感觉使用起来都很简单,没什么困难之处,最近在windows下要使用libcurl,编译和使用的时候踩了不少坑,特此记录一下。</p></blockquote><h1 id="认识libcurl"><a href="#认识libcurl" class="headerlink" title="认识libcurl"></a>认识libcurl</h1><p>libcurl是一个跨平台的开源的网络协议库,它支持http,https，ftp,telnet等协议,同样它支持https证书授权,使用起来简便不像其他的网络库一样复杂,想要知道更多关于libcurl的介绍,可以到官网<a href="https://cur.heaxx.se上去了解,在这里不做过多介绍。" target="_blank" rel="noopener">https://cur.heaxx.se上去了解,在这里不做过多介绍。</a></p><h1 id="编译libcurl"><a href="#编译libcurl" class="headerlink" title="编译libcurl"></a>编译libcurl</h1><p>在编译libcurl之前,需要先做如下配置</p><h2 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h2><ul><li>libcurl去官网下载源码 博主自己用的是curl-7.55.0 <a href="https://curl.haxx.se/download/curl-7.55.0.zip" target="_blank" rel="noopener">https://curl.haxx.se/download/curl-7.55.0.zip</a></li><li>openssl,下载openssl-1.0.2k,1.1.0以后的文件安装方法都换了 <a href="https://www.openssl.org/source/" target="_blank" rel="noopener">https://www.openssl.org/source/</a></li><li>下载perl解析器,编译依赖库openssl的时候需要用到<a href="https://www.activestate.com/activeperl/downloads" target="_blank" rel="noopener">https://www.activestate.com/activeperl/downloads</a></li><li>zlib下载1.2.11 <a href="http://zlib.net" target="_blank" rel="noopener">http://zlib.net</a></li></ul><h3 id="配置目录"><a href="#配置目录" class="headerlink" title="配置目录"></a>配置目录</h3><p>为了不愿跟博主一样再踩过很多坑以后，才编译成功,在你的盘符根目录下新建一个文件夹名叫libcurl-ssl,将下载的三个压缩包解压到该目录。</p><h3 id="ActiveState安装"><a href="#ActiveState安装" class="headerlink" title="ActiveState安装:"></a>ActiveState安装:</h3><p>执行安装程序,默认安装路径或者自定义路径都可以。</p><h3 id="zlib编译"><a href="#zlib编译" class="headerlink" title="zlib编译"></a>zlib编译</h3><ol><li>在你创建的文件夹下打开zlib-1.2.11\contrib\vstudio\vc14\zlibvc.sln,选择编译release版本,平台x86,x64自选。</li><li>编译过后,会在x86或者x64文件夹下的ZlibDllRelease文件夹中生成zlibwapi.dll和zlibwapi.lib文件</li></ol><h3 id="openssl编译"><a href="#openssl编译" class="headerlink" title="openssl编译"></a>openssl编译</h3><p>这一步算是比较麻烦,也容易出错的地方,因为只能通过命令行来进行编译</p><ol><li>在开始菜单中找到自带的vs本机工具命令提示符,你的vs版本 和要进行编译的平台自己选择。我用的是vs2015 x86</li><li>使用cd命令进入到你创建的文件夹下的openssl-1.0.2k中</li><li>命令行输入perl Configure VC-WIN32 no-asm</li><li>命令行输入ms\do_ms.bat</li><li>命令行输入nmake -f ms/ntdll.mak</li></ol><p>耐心等待编译结束,抽根烟回来就编译好了,查看编译过程只要不出现”stop”,”error”的,就算成功了,如果出现错误的话,最好是把整个文件夹删了，重新解压编译,如果留有编译失败的文件，再进行编译的话它可能会提示”无法解析xxx”。</p><p>接着将openssl-1.0.2k-&gt;inc32-&gt;openssl中所有的.h文件和openssl-1.0.2k-&gt;out32dll中的libeay32.lib、libeay32.dll、ssleay32.lib、ssleay32.dll一起复制到curl-7.55.0-&gt;lib-&gt;opensll中，如果lib文件夹下没有openssl,建立一个就可以了。</p><h3 id="libcurl编译"><a href="#libcurl编译" class="headerlink" title="libcurl编译"></a>libcurl编译</h3><p>libcurl直接使用vs进行编译,编译平台选择DLL DEBUG-DLL OpenSSL</p><ol><li>打开curl-7.55.0-&gt;projects-&gt;Windows-&gt;VC14-&gt;curl-all.sln,可能vs会提示升级工程，确定即可。</li><li>将libcurl设为启动项目,将libcurl的资源文件libcurl.rc移出。</li><li>右键项目选择属性-&gt;C/C++-&gt;预处理器-&gt;预处理器定义,将”BUILDING_LIBCURL”改成”CURL_STATICLIB”。接口函数不会被声明为导出函数</li><li>选择属性-&gt;链接器-&gt;输入-&gt;附加依赖项添加 libeay32.lib;ssleay32.lib;ws2_32.lib;wldap32.lib;前两个是为了openssl,后两个是curl必须依赖的。</li></ol><p>在编译成功后curl-7.55.0-&gt;build-&gt;Win32-&gt;VC14-&gt;DLL DEBUG-DLL OpenSSL文件夹中会生成有libcurld.lib和libcurld.dll(注意名字不是libcurl)</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ol><li>创建一个控制台应用,例如项目名叫Test,在你的Test项目下创建include文件夹,将curl-7.55.0-&gt;include目录下的curl文件夹,复制过去。</li><li>新建lib文件夹,将libcurl编译的libcurld.dll和libcurld.lib复制到lib。</li><li>将libcurld.dll和之前OpenSSL生成的libeay32.lib、ssleay32.dll各复制一份到项目exe文件下,否则会报错。会提示定位不到序数,编译的过,运行不过。</li><li>选择配置属性-&gt;C/C++-&gt;预处理器-&gt;预处理器定义,添加CURL_STATICLIB。</li><li>属性中的附加包含目录，附加库目录都在代码实现</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&quot;curl/curl.h&quot;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#pragma comment(lib,&quot;libcurld.lib&quot;)</span><br><span class="line"></span><br><span class="line">size_t CallBack(void *ptr, size_t size, size_t nmemb, void *stream)</span><br><span class="line">&#123;</span><br><span class="line">    string *str = (string*)stream;</span><br><span class="line">    cout &lt;&lt; *str &lt;&lt; endl;</span><br><span class="line">    (*str).append((char*)ptr, size*nmemb);</span><br><span class="line">    return size * nmemb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    easy_global_init(CURL_GLOBAL_ALL);</span><br><span class="line"></span><br><span class="line">    CURL *curl=easy_curl_init();</span><br><span class="line">    if(curl)</span><br><span class="line">    &#123;</span><br><span class="line">        curl_easy_setopt(curl,CURLOPT_URL,&quot;www.baidu.com&quot;);</span><br><span class="line"></span><br><span class="line">        string result;</span><br><span class="line">        //设置ssl</span><br><span class="line">        curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, false);</span><br><span class="line">        curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, false);</span><br><span class="line">        //开启调式信息</span><br><span class="line">        curl_easy_setopt(curl, CURLOPT_VERBOSE, 1);</span><br><span class="line">        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, CallBack);</span><br><span class="line">        curl_easy_setopt(curl,CURLOT_WRITEDATA,(void *)&amp;result);</span><br><span class="line">        curl_easy_setopt(curl, CURLOPT_NOSIGNAL, 1);</span><br><span class="line">        curl_easy_setopt(curl,CURLOPT_TIMEOUT,3);</span><br><span class="line"></span><br><span class="line">        CURLcode res=curl_easy_perform(curl);</span><br><span class="line">        if(CURLE_OK!=res)</span><br><span class="line">        &#123;</span><br><span class="line">            cerr&lt;&lt;&quot;curl_easy_perform() failed&quot;&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Windows下编译libcurl和使用&quot;&gt;&lt;a href=&quot;#Windows下编译libcurl和使用&quot; class=&quot;headerlink&quot; title=&quot;Windows下编译libcurl和使用&quot;&gt;&lt;/a&gt;Windows下编译libcurl和使用&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="网络编程" scheme="https://thorns.cn/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="libcurl" scheme="https://thorns.cn/tags/libcurl/"/>
    
  </entry>
  
</feed>
