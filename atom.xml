<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Thorn&#39;s Blog</title>
  
  <subtitle>不卑不亢 一如初心 但行善事 莫顾前程</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.thorns.cn/"/>
  <updated>2019-01-08T07:44:44.000Z</updated>
  <id>http://www.thorns.cn/</id>
  
  <author>
    <name>Thorn</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>String to Integer</title>
    <link href="http://www.thorns.cn/2019/01/07/String%20to%20Integer.html"/>
    <id>http://www.thorns.cn/2019/01/07/String to Integer.html</id>
    <published>2019-01-07T13:47:47.000Z</published>
    <updated>2019-01-08T07:44:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="String-to-Integer-atoi"><a href="#String-to-Integer-atoi" class="headerlink" title=" String to Integer(atoi) "></a><font face="Calibri" size="6"> String to Integer(atoi) </font></h1><h2 id="原题描述"><a href="#原题描述" class="headerlink" title="原题描述"></a>原题描述</h2><blockquote><p>Implement atoi which converts a string to an integer.<br>实现c语言中的atoi函数,将string类型转化成int</p></blockquote><p>实现时需要考虑的因素有:  </p><ol><li>溢出问题  </li><li>输入无效</li><li>丢弃所有空格</li><li>数字正负号</li></ol><p>关于溢出，对于像我这种记不清楚int32范围的人，可以直接用long long类型解决。<br>数字正负号可以使用一个标志位进行标识，代码如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">int myAtoi(string str)</span><br><span class="line">&#123;</span><br><span class="line">    int flag = 0,pos = 0;</span><br><span class="line">    long long number = 0;</span><br><span class="line">    </span><br><span class="line">    //丢弃前面的空白字符串</span><br><span class="line">    while (str[pos] == &apos; &apos;) </span><br><span class="line">        pos++;</span><br><span class="line">    //判断正负号,下标移到符号下一位</span><br><span class="line">    if (str[pos] == &apos;-&apos; || str[pos] == &apos;+&apos;)</span><br><span class="line">        flag = str[pos++] == &apos;-&apos; ? -1:1;</span><br><span class="line">    </span><br><span class="line">    while (str[pos] &gt;= &apos;0&apos; &amp;&amp; str[pos] &lt;= &apos;9&apos;) &#123;</span><br><span class="line">        number = 10 * number + (str[pos++]-&apos;0&apos;);</span><br><span class="line">        //判断是否超过int32的范围</span><br><span class="line">        if (number &gt;INT_MAX)</span><br><span class="line">            return flag == 1 ? INT_MAX:INT_MIN;</span><br><span class="line">    &#125;</span><br><span class="line">    return (int)(number * flag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;String-to-Integer-atoi&quot;&gt;&lt;a href=&quot;#String-to-Integer-atoi&quot; class=&quot;headerlink&quot; title=&quot; String to Integer(atoi) &quot;&gt;&lt;/a&gt;&lt;font face=&quot;Calib
      
    
    </summary>
    
      <category term="leetcode" scheme="http://www.thorns.cn/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Reverse interger</title>
    <link href="http://www.thorns.cn/2019/01/06/Reverse%20interger.html"/>
    <id>http://www.thorns.cn/2019/01/06/Reverse interger.html</id>
    <published>2019-01-05T17:47:47.000Z</published>
    <updated>2019-01-08T07:53:10.457Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Reverse-interger"><a href="#Reverse-interger" class="headerlink" title="Reverse interger"></a>Reverse interger</h1><p>将一个整数反转，需要考虑溢出。<br>leetcode 原题链接：<a href="https://leetcode.com/problems/reverse-integer/" target="_blank" rel="noopener">https://leetcode.com/problems/reverse-integer/</a><br>example: x=123,return 321<br>example: x=-123,return -321<br>此题难度easy，不过需要考虑的是反转之后溢出情况。int32的范围-2147483648,2147483647。直接贴代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int reverse(int x)</span><br><span class="line">&#123;</span><br><span class="line">    int res = 0;</span><br><span class="line">    while (x != 0) &#123;</span><br><span class="line">        //判断是否溢出</span><br><span class="line">        if (abs(res) &gt; INT_MAX/10)</span><br><span class="line">            return 0;</span><br><span class="line">        res = res *10 + x % 10;</span><br><span class="line">        x /= 10;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当然也可以定义一个long long类型的变量，如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//解法2</span><br><span class="line">int reverse(int x)</span><br><span class="line">&#123;</span><br><span class="line">    long long res=0;</span><br><span class="line">    while (x != 0) &#123;</span><br><span class="line">        res = res *10 + x % 10;</span><br><span class="line">        x /= 10;</span><br><span class="line">    &#125;</span><br><span class="line">    //判断溢出</span><br><span class="line">    return (res&gt;INT_MAX||res&lt;INT_MIN)?0:res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>解法一，是直接判断是否大于INT_MAX/10(即214748364)，当res&gt;214748364时，必定溢出。因为x的第一位只能是1或者2，所以再执行res=res*10+x/10就会溢出。<br>解法二，直接定义了一个long long类型，最后判断是否大于INT_MAX或者小于INT_MIN。个人推荐解法一。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Reverse-interger&quot;&gt;&lt;a href=&quot;#Reverse-interger&quot; class=&quot;headerlink&quot; title=&quot;Reverse interger&quot;&gt;&lt;/a&gt;Reverse interger&lt;/h1&gt;&lt;p&gt;将一个整数反转，需要考虑溢出
      
    
    </summary>
    
      <category term="leetcode" scheme="http://www.thorns.cn/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>2018年度个人终结</title>
    <link href="http://www.thorns.cn/2018/12/28/2018%E5%B9%B4%E5%BA%A6%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93.html"/>
    <id>http://www.thorns.cn/2018/12/28/2018年度个人总结.html</id>
    <published>2018-12-27T17:47:47.000Z</published>
    <updated>2019-01-08T04:06:40.989Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一转眼就是年底，不知不觉这已经是出来工作的第四个年头了。回望过去，感觉还是那个刀未佩妥已身在江湖的少年郎了。一切都太匆匆，希望在这节奏快的时代，有一篇文章能承载着在路上的味道。</p></blockquote><h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>&emsp;年初找到了一份自己喜欢，前景不错的工作，并且薪资也达到了理想的目标。了解了许多以前未接触的领域，有技术上的 区块链开发，duilib的界面开发，也有非技术上的，炒币 、期货 、外汇。</p><h3 id="缺点与不足"><a href="#缺点与不足" class="headerlink" title="缺点与不足"></a>缺点与不足</h3><p>&emsp;1.也许是一个人达到了心理的预期都会有一个放空期，下半年明显感觉自己在工作上，和对技术上都出现了严重的慵懒，复杂的不愿意去做，需要大量时间成本的不愿意去学习。  </p><p>&emsp;2.工作上的沟通交流明显不足，需要多锻炼沟通交流能力。好的交流能力能有效的突出自我，以及发现别人好的idea，审视自己的不足。  </p><p>&emsp;3.英文太差，英文不好的不一定是大佬，英文好的一定是大佬。在看文档时，去靠google翻译太耗时，需要提升英文能力。</p><h3 id="计划与改善"><a href="#计划与改善" class="headerlink" title="计划与改善"></a>计划与改善</h3><p>&emsp;1.多看优秀的源码与书籍，与学习。</p><blockquote><p>看redis,telegram,libevent实现，读《深度探索C++对象模型》,《Windows核心编程》,《Python3爬虫》，学习boost，muduo,spark,kafka。  </p></blockquote><p>&emsp;2.提高英文水平，储备词汇量，英文技术文档时尽量自己翻译。<br>&emsp;3.积极与同事沟通交流，多参加线下的技术交流会。</p><h3 id="工作总结"><a href="#工作总结" class="headerlink" title="工作总结"></a>工作总结</h3><p>&emsp;这一年里自我评价提升很快，个人认为跟工作环境以及公司团队的一个良好气氛是离不开的，对比去年由于个人沟通交流能力薄弱，工作上有许多地方没能跟上级及时沟通，不仅导致公司产品开发进度且自己也没能得到一个好的提升，在这里要感谢现在的领导和公司，得以借助他们良好的沟通能力和好的平台，让我在工作中不断的学习、提升、进步。谢谢您们！<br>工作上接触的知识面很多，当然也加了不少班，熬了不少夜。技术面相比较以前广度多了不少，如区块链，钱包，交易所等这些都是曾经未接触，随之而来的缺点就是深度不够。有很多原理、底层、框架的东西都不太明白，真正要用的时候不能信手拈来，出错时也只能靠google救场。在这里需要多看源码，多去深入学习好的架构和设计思想。</p><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>生活上这一年要比去年过得有趣精致一点，从以前不能忍受合租到合租再到现在的独居，虽然房租贵了很多，但是值得的。想看书时，再也听不到打游戏的声音，想播放自己喜欢的音乐时，再也没有其它的歌声扰乱自己。一个人安安静静做着喜欢的事，听着喜欢的歌，美哉！偶尔周末也会自己做做饭，爬爬山，去参加技术沙龙，听听喜欢的歌手的livehouse。 </p><p>生活上由于理财意识不高，月光，导致过了一段比较拮据的时光，不过挺感谢这段时光，也让我经历了一段旁人未经历过的风景。一个人的生活最大的缺点就是作息不规律，晚上经常熬夜，吃饭不规律，饮食习惯不好，这些希望能在后面的时间日渐改善。</p><h3 id="缺点与不足-1"><a href="#缺点与不足-1" class="headerlink" title="缺点与不足"></a>缺点与不足</h3><p>&emsp;1.生活作息时间和饮食习惯极其不好<br>&emsp;2.生活很慵懒，尤其是下半年周末很少出去走动<br>&emsp;3.理财意识不高，典型月光族一枚</p><h3 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h3><p>&emsp;1.加强理财意识，物质基础决定上层建筑<br>&emsp;2.生活作息规律，培养一个好的饮食习惯（胃）</p><h2 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h2><p>2018读过的书:<br>《雨季不再来》<br>《送你一匹马》<br>《万水千山走遍》<br>《云去云来》<br>《窗里窗外》<br>《白夜行》<br>《人间失格》<br>《黄金时代》<br>《浪潮之巅》<br>《Effective C++》  </p><p>阅读量太少了，一年十本书都未到…很羞愧，在来年需要提高阅读量，少读无内容的书籍，学习是整个人生最有意义的事情。</p><h2 id="电影"><a href="#电影" class="headerlink" title="电影"></a>电影</h2><p>18年印象深刻的电影:<br>对于电影，平时看的少，所以只能慢慢追以前比较经典的电影。  </p><p>《重庆森林》&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;——“今天他喜欢凤梨，明天他可以喜欢别的”<br>《蝴蝶效应》&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;——“即使细微如蝴蝶鼓舞，也能煽动千里之飓风”<br>《海上钢琴师》&ensp;&ensp;&ensp;&ensp;&ensp; ——“fuck the regulations”<br>《泰坦尼克号》&ensp;&ensp;&ensp;&ensp;&ensp; ——“Can I take your name,please,love? Dawson.Rose Dawson”<br>《海边的曼彻斯特》&ensp;&ensp;——“I cann’t beat it”    </p><h2 id="2018实现的目标"><a href="#2018实现的目标" class="headerlink" title="2018实现的目标"></a>2018实现的目标</h2><p>1.找到一份金融行业 且团队气氛不错 薪资到达个人目标<br>2.换一台mbp<br>3.租一间自己满意的小窝<br>4.去听李志的现场<br>5.去听陈粒的现场<br>5.去香港旅游一次<br>6.去南京旅游一次</p><h2 id="2018未实现的目标"><a href="#2018未实现的目标" class="headerlink" title="2018未实现的目标"></a>2018未实现的目标</h2><p>1.存款未到  (写到这里，一两点光着身子的我瑟瑟发抖)<br>2.阅读书籍量未到10本<br>3.英文词汇量未到<br>4.出国旅行跳伞未到<br>5.杰伦的现场未到    (事出有因，可恨的黄牛！！)<br>6.冠希的现场未到    </p><h2 id="2019目标"><a href="#2019目标" class="headerlink" title="2019目标"></a>2019目标</h2><p>1.通过不断学习，技术上能得到一个质的提升<br>2.培养一门业余技能<br>3.提高理财意识，存款到达心中的目标<br>4.阅读累计20本书<br>5.坚持两周写一篇博客<br>6.提升自己学历<br>7.芭提雅跳伞<br>8.西藏骑行<br>9.去听叁叁肆现场一次<br>10.体验不回家过年<br>11.做五件有意义的事情</p><p>End</p><blockquote><p>“成为自己想成为的人，做自己想做的事。即使失败了，也可以重新再来”<br>别怕失败，大不了从头来过，你懂的！          ——陈冠希  </p></blockquote><p>最后附一张冠希的图以激励自己。<br><img src="http://pkzvfevbf.bkt.clouddn.com/edc.jpeg" alt="avatar"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;一转眼就是年底，不知不觉这已经是出来工作的第四个年头了。回望过去，感觉还是那个刀未佩妥已身在江湖的少年郎了。一切都太匆匆，希望在这节奏快的时代，有一篇文章能承载着在路上的味道。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;工作&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="Life" scheme="http://www.thorns.cn/categories/Life/"/>
    
    
  </entry>
  
  <entry>
    <title>这么多年你一个人 一直在走</title>
    <link href="http://www.thorns.cn/2018/12/09/1208.html"/>
    <id>http://www.thorns.cn/2018/12/09/1208.html</id>
    <published>2018-12-09T03:21:40.000Z</published>
    <updated>2018-12-27T08:17:07.785Z</updated>
    
    <content type="html"><![CDATA[<h1 id="这么多年你一个人-一直在走"><a href="#这么多年你一个人-一直在走" class="headerlink" title="这么多年你一个人 一直在走"></a>这么多年你一个人 一直在走</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>恩，昨天某个逼让我失了声感冒了。中午起床极度不爽，得以于此，借深圳余温未散抽空记录一下生活。  </p></blockquote><p>&emsp;听他的歌时间不长，不到一年。忘记了从哪首开始，也不知道该在哪首结束。<br>&emsp;记忆中应该是在知晓了“祝星”这号人物的时候，才知道了“港岛妹妹”的西班牙馅饼。那段时间酷爱三毛笔下的西班牙，撒哈拉。也因此喜欢上了陈粒的《历历万乡》。不同于其它人对“港岛妹妹”的幻想，对“西班牙馅饼”的期待，我了解的“港岛妹妹”不过是某装逼犯的自淫，“西班牙馅饼”也不过是一张明信片。  </p><h2 id="你说你遇见了一大堆奇怪的人"><a href="#你说你遇见了一大堆奇怪的人" class="headerlink" title="你说你遇见了一大堆奇怪的人"></a>你说你遇见了一大堆奇怪的人</h2><p>&emsp;时光就这样悄悄的流走，早高峰 晚高峰，有身穿OL装的白领正拿着粉底盒涂抹着她那疲惫的妆容，有一张张放声大笑的脸努力汲取着手机上短视频的笑点，也有戴着耳机或是手拿一部kindle为考研，为四六级而准备的人群……像是厌倦了一切变得麻木，低头听歌，听歌抬头，抬头下车。忽然在某一早晨，耳边隐约回响起一句“这么多年你一个人，一直在走，你说你遇见了一大堆奇怪的人，他们看上去好像都比你开心。”至此我明白，在那一座六朝古都，那座为一人种满了梧桐的城市，有一个独立的灵魂用它那低沉，嘶吼的声音在我耳边激荡盘旋，不能离去。从此，喜欢李志的歌一发不可收拾。</p><h2 id="他们指向左，他们指向右"><a href="#他们指向左，他们指向右" class="headerlink" title="他们指向左，他们指向右"></a>他们指向左，他们指向右</h2><p>&emsp;有人说不能常听他的歌，会变得浑身充满负能量的人。对于这种说法，我身边的一位朋友，告诉我他“每天都是靠这逼的歌坚持下去的”，他的歌充满意义，带有思考。哈哈哈，写在这里的时候，真…<br>关于这首歌还是不提为好。有想研究的自个研究去。  </p><p><img src="/images/李志.jpeg" alt="avatar"></p><a id="more"></a><h2 id="这个世界会好的"><a href="#这个世界会好的" class="headerlink" title="这个世界会好的"></a>这个世界会好的</h2><p>昨天他的压轴，一出场全场齐呼“逼哥牛逼，逼哥牛逼”！第一眼看到真人，一顶老旧的灰色帽子，一件老旧的灰色短袖(出发的时候朋友叫我带衣服，嫌麻烦没带，这两天深圳满30减15的温度活动不得不说很商业化，但看到他穿着一件短袖，“牛逼”！),一条老旧的蓝色牛仔，跟每天在视频上看到的并无差别。跟上面的图片搭配一模一样，心中不禁想这套衣服多久没换了？还好牙齿洗了。旁边的一位，额 怎么来形容呢，对于年龄比自己的大的吧 叫一声美女显得轻浮，说叫一个女人吧显得又太不会用词。那就叫旁边的一位可爱的女孩吧。《逃避可耻却有用》里面讲“可爱是最高级的形容词”，说的真对。一直在哪欢呼，在台底下跟逼哥抬扛，逼哥唱到“妈妈”的时候，她吼“恩，我在这里”，说到“一根烟的时候”，她回“是两根”，很喜欢这种氛围。全程一个小时下来，逼哥在结束开启了他的逼言逼语，后面的旗子挥舞着一个”B”字。他讲40年来改革开放，讲我们应该要谢谢，要学会感恩。嗯，这个世界会好的。</p><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>他就是b言b语，五块钱的发型，老套的衣服，一口大黄牙。却让人不反感，你知道他开始装逼了，听完了。你甚至都想去买两包南京(九五之尊)给他点着，既然这次没机会给你散烟，那就劳驾我拉着我的基友亲自去热河给你散一根南京的南京吧。   </p><p>朋友对我刁侃道:你走在宋美龄大道上风花雪月，我走在义和五龙街感叹人生  </p><p>我回:不是因为六朝古都，不是因为哪座种满了梧桐的城市。<br>我带你去南京听热河，带你去武林门听杭州。<br>自带装逼属性有没有！<br><img src="/images/1.jpeg" alt="avatar"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;这么多年你一个人-一直在走&quot;&gt;&lt;a href=&quot;#这么多年你一个人-一直在走&quot; class=&quot;headerlink&quot; title=&quot;这么多年你一个人 一直在走&quot;&gt;&lt;/a&gt;这么多年你一个人 一直在走&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;恩，昨天某个逼让我失了声感冒了。中午起床极度不爽，得以于此，借深圳余温未散抽空记录一下生活。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;emsp;听他的歌时间不长，不到一年。忘记了从哪首开始，也不知道该在哪首结束。&lt;br&gt;&amp;emsp;记忆中应该是在知晓了“祝星”这号人物的时候，才知道了“港岛妹妹”的西班牙馅饼。那段时间酷爱三毛笔下的西班牙，撒哈拉。也因此喜欢上了陈粒的《历历万乡》。不同于其它人对“港岛妹妹”的幻想，对“西班牙馅饼”的期待，我了解的“港岛妹妹”不过是某装逼犯的自淫，“西班牙馅饼”也不过是一张明信片。  &lt;/p&gt;
&lt;h2 id=&quot;你说你遇见了一大堆奇怪的人&quot;&gt;&lt;a href=&quot;#你说你遇见了一大堆奇怪的人&quot; class=&quot;headerlink&quot; title=&quot;你说你遇见了一大堆奇怪的人&quot;&gt;&lt;/a&gt;你说你遇见了一大堆奇怪的人&lt;/h2&gt;&lt;p&gt;&amp;emsp;时光就这样悄悄的流走，早高峰 晚高峰，有身穿OL装的白领正拿着粉底盒涂抹着她那疲惫的妆容，有一张张放声大笑的脸努力汲取着手机上短视频的笑点，也有戴着耳机或是手拿一部kindle为考研，为四六级而准备的人群……像是厌倦了一切变得麻木，低头听歌，听歌抬头，抬头下车。忽然在某一早晨，耳边隐约回响起一句“这么多年你一个人，一直在走，你说你遇见了一大堆奇怪的人，他们看上去好像都比你开心。”至此我明白，在那一座六朝古都，那座为一人种满了梧桐的城市，有一个独立的灵魂用它那低沉，嘶吼的声音在我耳边激荡盘旋，不能离去。从此，喜欢李志的歌一发不可收拾。&lt;/p&gt;
&lt;h2 id=&quot;他们指向左，他们指向右&quot;&gt;&lt;a href=&quot;#他们指向左，他们指向右&quot; class=&quot;headerlink&quot; title=&quot;他们指向左，他们指向右&quot;&gt;&lt;/a&gt;他们指向左，他们指向右&lt;/h2&gt;&lt;p&gt;&amp;emsp;有人说不能常听他的歌，会变得浑身充满负能量的人。对于这种说法，我身边的一位朋友，告诉我他“每天都是靠这逼的歌坚持下去的”，他的歌充满意义，带有思考。哈哈哈，写在这里的时候，真…&lt;br&gt;关于这首歌还是不提为好。有想研究的自个研究去。  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/李志.jpeg&quot; alt=&quot;avatar&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Life" scheme="http://www.thorns.cn/categories/Life/"/>
    
    
  </entry>
  
  <entry>
    <title>traits编程技法</title>
    <link href="http://www.thorns.cn/2018/08/31/traits%E7%BC%96%E7%A8%8B%E6%8A%80%E6%B3%95.html"/>
    <id>http://www.thorns.cn/2018/08/31/traits编程技法.html</id>
    <published>2018-08-31T04:06:20.000Z</published>
    <updated>2018-08-30T16:10:17.468Z</updated>
    
    <content type="html"><![CDATA[<h1 id="STL之traits编程技法的理解"><a href="#STL之traits编程技法的理解" class="headerlink" title="STL之traits编程技法的理解"></a>STL之traits编程技法的理解</h1><blockquote><p>注:很多内容节选自《STL源码剖析》,见上自己的理解，特此记录   </p></blockquote><ul><li>traits又被叫做”特性萃取技术”,用于提取被”被传进来的对象对应的返回类型,让同一个接口实现对应的功能。因为STL的算法和容器是分离的,两者通过迭代器连接,算法的实现并不知道传进来的是什么,萃取器相当于接口和实现之间加一层封装,来隐藏一些细节并协助调用合适的方法。<h2 id="迭代器的类型"><a href="#迭代器的类型" class="headerlink" title="迭代器的类型"></a>迭代器的类型</h2>我们知道迭代器有五种类型,分别是    </li></ul><ol><li>value_type(迭代器所指对象的类型)</li><li>difference_type(用来表示两个迭代器之间的距离)</li><li>reference_type(迭代器所指对象的引用)</li><li>point_type(迭代器所指的对象)</li><li>iterator_category(标识迭代器的移动特性和可以对迭代器进行的操作,大致可以分为五类)<br> Input iterator<br> Output iterator<br> Forward iterator<br> Bidirectional iterator<br> Random Access iterator     </li></ol><h2 id="声明内嵌型别"><a href="#声明内嵌型别" class="headerlink" title="声明内嵌型别"></a>声明内嵌型别</h2><p>考虑一下，当我们需要实现某个函数时,且该函数的返回类型必须是value_type是，该怎么办？我们不能使用”template 参数推导机制”,毕竟推导机制推导的是参数，无法推导函数的返回值型别。<br>在这里我们就可以用到声明内嵌型别,来解决使用value_type用于函数的返回类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class T&gt;</span><br><span class="line">struct MyIter&#123;</span><br><span class="line">  typedef T value_type;     //内嵌型别声明</span><br><span class="line">  MyIter(T *p=0):ptr(p) &#123;&#125;</span><br><span class="line">  T&amp; operator*() const &#123;return *ptr;&#125;</span><br><span class="line">  private:</span><br><span class="line">    T *ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//使用value_type用于函数返回类型</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">typename I::value_type func(I ite)</span><br><span class="line">&#123;</span><br><span class="line">    return *ite;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//...</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Myiter&lt;int&gt; ite(new int(8));</span><br><span class="line">    cout&lt;&lt;func(ite)&lt;&lt;endl;  //输出:8</span><br><span class="line">&#125;</span><br><span class="line">```   </span><br><span class="line">func函数中的typename用意是在告诉编译器I::value_type是一个型别,因为T是一个template参数,在它被编译器具现化之前,编译器对T一无所悉,编译器不知道I::value_type代表的是一个型别还是一个member function或者是data member。   </span><br><span class="line">这样看起来结局了我们的问题,但是有个隐晦的陷阱:并不是所有的迭代器都是class type。原生指针就不是,如果不是class type,就无法为它定义内嵌型别。有没有好的解决办法呢？偏特化可以为我们解决这个问题。</span><br><span class="line">## 模板偏特化</span><br><span class="line">《STL源码剖析》一书上对模板偏特化的意义大致解释是:</span><br><span class="line">&gt; 如果class template拥有一个以上的template参数,我们可以针对其中某个(或数个,但非全部)template参数进行特化工作。换句话说,我们可以在泛化设计中提供一个特化版本。</span><br></pre></td></tr></table></figure></p><p>//萃取器<br>template <class i=""><br>struct iterator_traits{<br>  typedef typename T I::value_type value_type;<br>};</class></p><p>//偏特化版<br>template <class t=""><br>struct ierator_traits&lt;T*&gt;{<br>  typedef T value_type;<br>};</class></p><p>//偏特化过后的func函数<br>template <class t=""><br>typename iterator_traits<i>::value_type //这一整行是函数返回型别<br>func(I ite)<br>{<br>    return *ite;<br>}</i></class></p><p>int main()<br>{<br>    int a=8;<br>    int <em>p=&a;<br>    cout&lt;&lt;func(p)&lt;&lt;endl;    //传的类型是int</em><br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">上面我们通过偏特化版就可以获取原始指针的型别用来定义函数返回型别,可能会问如果原始指针是个pointer-to-const怎么办呢？没关系再偏特化一个版本就好了</span><br></pre></td></tr></table></figure><p>template <class t=""><br>struct iterator_traits<const t*="">{<br>  typedef T value_type;<br>};<br><code>`</code><br>以上就是stl中使用的traits技法，traits就像一台”特性萃取机”,萃取各个迭代器的相应型别。</const></class></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;STL之traits编程技法的理解&quot;&gt;&lt;a href=&quot;#STL之traits编程技法的理解&quot; class=&quot;headerlink&quot; title=&quot;STL之traits编程技法的理解&quot;&gt;&lt;/a&gt;STL之traits编程技法的理解&lt;/h1&gt;&lt;blockquote&gt;

      
    
    </summary>
    
      <category term="STL源码剖析" scheme="http://www.thorns.cn/categories/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
    
      <category term="STL traits" scheme="http://www.thorns.cn/tags/STL-traits/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu安装Mongodb及配置</title>
    <link href="http://www.thorns.cn/2018/08/23/ubuntu%E5%AE%89%E8%A3%85Mongodb%E5%8F%8A%E9%85%8D%E7%BD%AE.html"/>
    <id>http://www.thorns.cn/2018/08/23/ubuntu安装Mongodb及配置.html</id>
    <published>2018-08-23T02:58:20.000Z</published>
    <updated>2018-08-24T04:10:58.680Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ubuntu安装Mongodb及配置"><a href="#ubuntu安装Mongodb及配置" class="headerlink" title="ubuntu安装Mongodb及配置"></a>ubuntu安装Mongodb及配置</h1><p>官方下载地址: <a href="https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-amazon2-4.0.1.tgz" target="_blank" rel="noopener">https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-amazon2-4.0.1.tgz</a>  </p><p>使用curl进行下载<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -O https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-amazon2-4.0.1.tgz</span><br></pre></td></tr></table></figure></p><p>解压<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf mongodb-linux-x86_64-ubuntu1404-4.0.1.tgz</span><br></pre></td></tr></table></figure></p><p>移动到用户local目录下(可自定义)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mv mongodb-linux-x86_64-ubuntu1404-4.0.1.tgz /usr/local/mongodb</span><br></pre></td></tr></table></figure></p><p>创建数据库目录和日志目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /data/db</span><br><span class="line">sudo mkdir /data/logs</span><br></pre></td></tr></table></figure></p><p>创建配置文件,启动mongod时需要<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/local/mongodb/bin/mongodb.conf #将配置文件放在mongodb/bin目录下</span><br><span class="line"></span><br><span class="line">dbpath=/data/db/    #db路径</span><br><span class="line">logpath=/data/logs/mongodb.log  #log路径</span><br><span class="line">fork=true   #以后台模式mongos进程  </span><br><span class="line">port=27017</span><br></pre></td></tr></table></figure></p><p>配置mongodb环境变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bashrc</span><br><span class="line">#在最后添加</span><br><span class="line">export PATH=$PATH:/usr/local/mongodb/bin</span><br><span class="line">#退出使用source命令使设置生效</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure></p><p>接下来就可以开启mongodb服务了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mongod -f /usr/local/mongodb/bin/mongodb.conf</span><br><span class="line">#使用mongo连接服务</span><br><span class="line">mongo</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ubuntu安装Mongodb及配置&quot;&gt;&lt;a href=&quot;#ubuntu安装Mongodb及配置&quot; class=&quot;headerlink&quot; title=&quot;ubuntu安装Mongodb及配置&quot;&gt;&lt;/a&gt;ubuntu安装Mongodb及配置&lt;/h1&gt;&lt;p&gt;官方下载地址
      
    
    </summary>
    
      <category term="Mongodb" scheme="http://www.thorns.cn/categories/Mongodb/"/>
    
    
      <category term="Mongodb" scheme="http://www.thorns.cn/tags/Mongodb/"/>
    
  </entry>
  
  <entry>
    <title>谈谈ss和socks5协议</title>
    <link href="http://www.thorns.cn/2018/05/06/%E8%B0%88%E8%B0%88socks5%E5%8D%8F%E8%AE%AE%E5%92%8Css.html"/>
    <id>http://www.thorns.cn/2018/05/06/谈谈socks5协议和ss.html</id>
    <published>2018-05-06T08:12:32.000Z</published>
    <updated>2018-05-06T08:20:28.008Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ss和socks5协议"><a href="#ss和socks5协议" class="headerlink" title="ss和socks5协议"></a>ss和socks5协议</h1><blockquote><p>本文首发于个人博客:<a href="http://www.thorns.cn">www.thorns.cn</a></p></blockquote><p>前言:由于最近公司需要一个自己的代理服务,所以花了一周的时间去研究了下shadowsocks实现的原理,以及socks5协议。</p><h1 id="认识Shadowsocks"><a href="#认识Shadowsocks" class="headerlink" title="认识Shadowsocks"></a>认识Shadowsocks</h1><p>Shadowsocks是一个能骗过GFW的网络代理工具,它把我们要访问的数据请求,比如google,youtube，facebook…进行加密后传输到GFW外的服务端,由服务端去访问目标站点再加密返回给我们,网络中的GFW由于不知道传输的原内容是什么只好放行,于是就完成了我们所谓的”翻墙”。  </p><h1 id="Shadowsocks原理"><a href="#Shadowsocks原理" class="headerlink" title="Shadowsocks原理"></a>Shadowsocks原理</h1><p>SS(Shadowsocks)由两部分组成,运行在本地的ss-local和防火墙之外服务器上的ss-server。ss-local的职责是在本机启动和监听一个服务,本地软件的网络请求都会先发送到ss-local,ss-local收到来自本地软件的网络请求后,把要传输的原数据根据用户配置的加密方法和密码进行加密,再转发到服务端。ss-server的职责是在墙外服务器启动和监听一个服务,当服务端收到ss-local转发过来的数据时,会根据用户配置的加密方法和密码对数据进行解密,同时还会解socks5协议，然后会把解密后的数据转发到真正的请求目标服务地址(例如Google),以下是整个流程图.<br><img src="/images/liucheng.png" alt="avatar"></p><h1 id="Socks5协议介绍"><a href="#Socks5协议介绍" class="headerlink" title="Socks5协议介绍"></a>Socks5协议介绍</h1><p>SS的数据传输是建立在socks5协议之上的，Socks5是TCP/IP的网络代理协议，socks5有协商认证请求部分,个人更喜欢把他叫做Protocol Handshake。</p><h2 id="协商版本和验证方法"><a href="#协商版本和验证方法" class="headerlink" title="协商版本和验证方法"></a>协商版本和验证方法</h2><p>当我们的客户端向服务端建立连接之后,客户端就会向服务端进行协商,发送的数据包如下:<br><img src="/images/xs.png" alt="avatar"></p><p>其中各字段的含义如下:<br>VER:代表SOCKS的版本,SOCKS5 默认为0x05,固定长度一个字节。<br>NMETHODS:表示第三个字段的长度(也就是有几种认证方法),长度也是一个字节<br>METHODS:表示客户端支持的验证方式,可以有多种,长度1-255字节。<br>支持的验证方式有:  </p><ul><li>0x00:NO AUTHENTICATION REQUIRED（不需要验证）  </li><li>0x01:GSSAPI (通用安全服务应用程序接口)  </li><li>0x02:USERNAME/PASSWD(用户名密码)  </li><li>0x03:IANA ASSIGNED(至 0x’7F’ IANA 分配)</li><li>0x80:RESERVED FOR PRIVATE METHODS(至 0x’FE’ 私人方法保留)  </li><li>0xff:NO ACCEPTABLE METHODS(没有可接受的方法)<br>当服务端收到客户端的验证机信息之后，就要回应客户端提供哪种验证方式的信息。服务端回应的包格式如下:<br><img src="/images/xs1.png" alt="avatar"></li><li>VER:代表SOCKS的版本,SOCKS5默认为0x05,长度一个字节。  </li><li>METHOD:代表服务端回应客户端需要哪种验证方式,可以为上面六种验证方式之一   </li></ul><p>举个例子,比如客户端发送的包是 0x05 0x01 0x02，如果服务端不需要验证就会返回0X05 0X00,需要验证就会返回0x05 0x02,接下来客户端就需要进行认证这一步，也就是把用户名和密码发送给服务端进行认证,在这里我就不介绍认证这一步了,直接说请求这一步。</p><h2 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h2><p>客户端发起的连接由服务端验证通过后,客户端下一步就应该把要访问的目的网站地址给服务端,服务端得到地址后再去请求真正的目标服务。这一步客户端需要发送的包格式如下:<br><img src="/images/re.png" alt="avatar"></p><p>各个字段含义如下:</p><ul><li>VER:socks的版本  </li><li>CMD:代表客户端请求的类型，值长度1个字节,有三种类型:  <ol><li>Connect: 0x01  </li><li>BIND: 0x02</li><li>UDP: 0x03</li></ol></li><li>RSV:保留字段,默认0x00,长度1个字节</li><li>ATYP:代表请求的远程服务器地址类型,长度1个字节，三种类型:<ol><li>IPV4: 0x01</li><li>IPV6: 0x04</li><li>DOMAINNAME: 0x03</li></ol></li><li>DST.ADDR:代表远程服务器的地址,根据ATYP进行解析,值长度不定  </li><li>DST.PORT:代表远程服务器的端口,值长度2个字节</li></ul><p>服务端再收到客户端告诉的目标服务地址后，便和目标进行连接,不管成功与否,服务器都应该把连接的结果告诉客户端.如果连接成功的情况下,服务端返回的包格式如下:<br><img src="/images/sre.png" alt="avatar"></p><p>各个字段含义如下:</p><ul><li>REP:代表响应码,值长度1个字节，有如下类型<ol><li>0x00:succeeded(成功)</li><li>0x01:general SOCKS server failure(socks5服务器失败)</li><li>0x02:connection not allowed by ruleset</li><li>0x03:Network unreachable(网络无法访问)</li><li>0x04:Host unreachable(主机无法访问)</li><li>0x05:Connection refused(拒绝连接)</li><li>0x06:TTL expired(TTL 超时)</li><li>0x07:Command not supported(命令不支持)</li><li>0x08:Address type not supported(地址类型不受支持)</li><li>0x09:to 0xFF unassigned</li></ol></li><li>RSV:保留字,值长度一字节  </li><li>BND.ADDR:表示绑定地址,值长度不定  </li><li>BND.PORT:表示绑定端口,值长度2字节  </li></ul><h2 id="数据转发"><a href="#数据转发" class="headerlink" title="数据转发"></a>数据转发</h2><p>客户端在收到来自服务器成功的响应后，就会开始发送数据给本地代理，本地代理加密后进行转发给服务端,服务端解密之后访问最终目标服务。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>SOCKS5协议的目的就是为了把原本应该在本机直接请求目标服务的流程,放到了服务端去代理 客户端访问.运行流程如下:</p><p>本地代理和服务端协商认证请求<br>本地代理告诉服务端目标服务的地址<br>服务端去访问目标服务,成功后告诉本地代理<br>本机开始发送原本应发送到目标服务的数据给服务端,由服务端完成数据转发  </p><p>注:以上内容有很多部分都是参考RFC1928,和其他博主发表的博文，借鉴而来。如果感觉有什么地方不对或者不同见解的，都可以提出争议,以立即改正。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ss和socks5协议&quot;&gt;&lt;a href=&quot;#ss和socks5协议&quot; class=&quot;headerlink&quot; title=&quot;ss和socks5协议&quot;&gt;&lt;/a&gt;ss和socks5协议&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本文首发于个人博客:&lt;a href=&quot;ht
      
    
    </summary>
    
      <category term="网络编程" scheme="http://www.thorns.cn/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="socks" scheme="http://www.thorns.cn/tags/socks/"/>
    
  </entry>
  
  <entry>
    <title>More Effective C++ 8:new和delete</title>
    <link href="http://www.thorns.cn/2018/05/03/new.html"/>
    <id>http://www.thorns.cn/2018/05/03/new.html</id>
    <published>2018-05-02T20:04:44.000Z</published>
    <updated>2018-12-09T05:30:05.040Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>最近在看侯捷译的More Effective C++,看的过程有不少收获,发现自己对C++很多地方其实没有过多去了解,收获很多,记录一下。</p></blockquote><h1 id="三种new和delete"><a href="#三种new和delete" class="headerlink" title="三种new和delete"></a>三种new和delete</h1><p>我们知道,new和delete都是C++里的关键字,同时也是操作符。new负责分配内存，delete释放内存。new和delete都有new operator、operator new，placement new，delete operator。下面分别介绍这几种操作</p><h2 id="new-operator和delete-operator"><a href="#new-operator和delete-operator" class="headerlink" title="new operator和delete operator"></a>new operator和delete operator</h2><p>new operator和delete operator就是我们经常使用的new和delete,这两个操作符是由语言内建的,就像sizeof操作符一样，不能被改变意义。当我们写出这样的代码时new operatorf和new delete在执行时分为两步:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string *ps=new string(&quot;new operator&quot;);</span><br><span class="line">delete ps;</span><br></pre></td></tr></table></figure><ol><li>new operator 会先执行分配内存的操作,它会调用一个只分配内存的函数,这个函数就是operator new,它分配足够的内存，用来放置对象。new delete在释放内存前，会先调用对象的析构函数.</li><li>当new operator分配完内存的时候,它会调用一个构造函数,为刚才分配的内存中的对象设定初值。而delete operator调用完析构函数时,它会调用一个释放内存的函数 operator delete,这时候才会释放对象所占用的内存。</li></ol><p>以上两行代码，拆分开来就是这样,先调用构造函数,分配内存，调用析构函数，释放内存,在编译器中的操作如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void *memory=operator new(sizeof(string)); //取得原始内存</span><br><span class="line">call string::string(&quot;Memory Management&quot;) on*memory;//将内存中的对象初始化</span><br><span class="line">string *ps=static_cast&lt;string*&gt;(memory)；</span><br></pre></td></tr></table></figure><ul><li>注意new operator 和new delete都不可以被重载。</li></ul><h2 id="operator-new和operator-delete"><a href="#operator-new和operator-delete" class="headerlink" title="operator new和operator delete"></a>operator new和operator delete</h2><p>上面一直说到new和delete其实在内部都会调用到这两个函数，这两个函数到底跟new和delete有什么区别呢？通常operator new ,operator delete声明如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void *ps=operator new(sizeof(string));</span><br><span class="line">operator delete(ps);</span><br></pre></td></tr></table></figure><h2 id="placement-new-定位new"><a href="#placement-new-定位new" class="headerlink" title="placement new(定位new)"></a>placement new(定位new)</h2><blockquote><p>写这篇文章,其实主要是写这个用法，还记得看到这个用法的时候，是在侯捷翻译的另一本书《STL 源码剖析》在讲空间配置器时看见的。</p></blockquote><p>placement new是operator new的一种特殊版本,也是new operator的另一种用法,在已分配的内存上构造对象。要使用placement new必须要包含头文件new,#include或者#include&lt;new.h&gt;,调用示例就直接用书上的了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Widget</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Widget(int widgetSize);</span><br><span class="line">&#125;;</span><br><span class="line">Widget *constructWidgetInBuffer(void *buffer,int widgetSize)</span><br><span class="line">&#123;</span><br><span class="line">    return new(buffer) Widget(widgetSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此函数返回指针,指向一个Widget对象,它被构造于传递给此函数的一块内存缓冲区上。在函数内部唯一的表达式就是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new (buffer) Widget(widgetSize);</span><br></pre></td></tr></table></figure><p>于是,在buffer指向的这边空间，就构造了一个Widget对象。</p><p>注意,如果你使用了placement new，在某块内存中产生对象,应该避免对那块内存使用delete operator。因为这个delete operator会调用operator delete来释放内存,但是该内存内含的对象最初并非是由operator new分配得来的,毕竟placement new只是返回它所接受的指针而已,应该直接调用该对象的析构,然后在释放内存。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void *mallocShared(size_t size);</span><br><span class="line">void freeShared(void *memory);</span><br><span class="line">void *sharedMemory=mallocShared(sizeof(Widget));</span><br><span class="line">Widget *pw=constructWidgeInBuffer(sharedMemory,10);//placement new用法</span><br><span class="line">...</span><br><span class="line">delete pw;//错。sharedMemory来自mallocShared，不是来自operator new</span><br><span class="line">pw.~Widget();  //可以，析构pw所指的Widget对象,但并未释放Widget占用的内存</span><br><span class="line">freeShared(pw);  //可以,释放pw所指的内存,不调用任何析构函数</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;最近在看侯捷译的More Effective C++,看的过程有不少收获,发现自己对C++很多地方其实没有过多去了
      
    
    </summary>
    
      <category term="More Effective C++" scheme="http://www.thorns.cn/categories/More-Effective-C/"/>
    
    
      <category term="More Effective C++" scheme="http://www.thorns.cn/tags/More-Effective-C/"/>
    
  </entry>
  
  <entry>
    <title>Windows下编译libcurl和使用</title>
    <link href="http://www.thorns.cn/2018/04/01/Windows%E4%B8%8B%E7%BC%96%E8%AF%91libcurl.html"/>
    <id>http://www.thorns.cn/2018/04/01/Windows下编译libcurl.html</id>
    <published>2018-04-01T15:47:44.000Z</published>
    <updated>2018-05-06T07:38:54.864Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Windows下编译libcurl和使用"><a href="#Windows下编译libcurl和使用" class="headerlink" title="Windows下编译libcurl和使用"></a>Windows下编译libcurl和使用</h1><blockquote><p>之前在Linux下使用过wget和curl,感觉使用起来都很简单,没什么困难之处,最近在windows下要使用libcurl,编译和使用的时候踩了不少坑,特此记录一下。</p></blockquote><h1 id="认识libcurl"><a href="#认识libcurl" class="headerlink" title="认识libcurl"></a>认识libcurl</h1><p>libcurl是一个跨平台的开源的网络协议库,它支持http,https，ftp,telnet等协议,同样它支持https证书授权,使用起来简便不像其他的网络库一样复杂,想要知道更多关于libcurl的介绍,可以到官网<a href="https://cur.heaxx.se上去了解,在这里不做过多介绍。" target="_blank" rel="noopener">https://cur.heaxx.se上去了解,在这里不做过多介绍。</a></p><h1 id="编译libcurl"><a href="#编译libcurl" class="headerlink" title="编译libcurl"></a>编译libcurl</h1><p>在编译libcurl之前,需要先做如下配置</p><h2 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h2><ul><li>libcurl去官网下载源码 博主自己用的是curl-7.55.0 <a href="https://curl.haxx.se/download/curl-7.55.0.zip" target="_blank" rel="noopener">https://curl.haxx.se/download/curl-7.55.0.zip</a></li><li>openssl,下载openssl-1.0.2k,1.1.0以后的文件安装方法都换了 <a href="https://www.openssl.org/source/" target="_blank" rel="noopener">https://www.openssl.org/source/</a></li><li>下载perl解析器,编译依赖库openssl的时候需要用到<a href="https://www.activestate.com/activeperl/downloads" target="_blank" rel="noopener">https://www.activestate.com/activeperl/downloads</a></li><li>zlib下载1.2.11 <a href="http://zlib.net" target="_blank" rel="noopener">http://zlib.net</a></li></ul><h3 id="配置目录"><a href="#配置目录" class="headerlink" title="配置目录"></a>配置目录</h3><p>为了不愿跟博主一样再踩过很多坑以后，才编译成功,在你的盘符根目录下新建一个文件夹名叫libcurl-ssl,将下载的三个压缩包解压到该目录。</p><h3 id="ActiveState安装"><a href="#ActiveState安装" class="headerlink" title="ActiveState安装:"></a>ActiveState安装:</h3><p>执行安装程序,默认安装路径或者自定义路径都可以。</p><h3 id="zlib编译"><a href="#zlib编译" class="headerlink" title="zlib编译"></a>zlib编译</h3><ol><li>在你创建的文件夹下打开zlib-1.2.11\contrib\vstudio\vc14\zlibvc.sln,选择编译release版本,平台x86,x64自选。</li><li>编译过后,会在x86或者x64文件夹下的ZlibDllRelease文件夹中生成zlibwapi.dll和zlibwapi.lib文件</li></ol><h3 id="openssl编译"><a href="#openssl编译" class="headerlink" title="openssl编译"></a>openssl编译</h3><p>这一步算是比较麻烦,也容易出错的地方,因为只能通过命令行来进行编译</p><ol><li>在开始菜单中找到自带的vs本机工具命令提示符,你的vs版本 和要进行编译的平台自己选择。我用的是vs2015 x86</li><li>使用cd命令进入到你创建的文件夹下的openssl-1.0.2k中</li><li>命令行输入perl Configure VC-WIN32 no-asm</li><li>命令行输入ms\do_ms.bat</li><li>命令行输入nmake -f ms/ntdll.mak</li></ol><p>耐心等待编译结束,抽根烟回来就编译好了,查看编译过程只要不出现”stop”,”error”的,就算成功了,如果出现错误的话,最好是把整个文件夹删了，重新解压编译,如果留有编译失败的文件，再进行编译的话它可能会提示”无法解析xxx”。</p><p>接着将openssl-1.0.2k-&gt;inc32-&gt;openssl中所有的.h文件和openssl-1.0.2k-&gt;out32dll中的libeay32.lib、libeay32.dll、ssleay32.lib、ssleay32.dll一起复制到curl-7.55.0-&gt;lib-&gt;opensll中，如果lib文件夹下没有openssl,建立一个就可以了。</p><h3 id="libcurl编译"><a href="#libcurl编译" class="headerlink" title="libcurl编译"></a>libcurl编译</h3><p>libcurl直接使用vs进行编译,编译平台选择DLL DEBUG-DLL OpenSSL</p><ol><li>打开curl-7.55.0-&gt;projects-&gt;Windows-&gt;VC14-&gt;curl-all.sln,可能vs会提示升级工程，确定即可。</li><li>将libcurl设为启动项目,将libcurl的资源文件libcurl.rc移出。</li><li>右键项目选择属性-&gt;C/C++-&gt;预处理器-&gt;预处理器定义,将”BUILDING_LIBCURL”改成”CURL_STATICLIB”。接口函数不会被声明为导出函数</li><li>选择属性-&gt;链接器-&gt;输入-&gt;附加依赖项添加 libeay32.lib;ssleay32.lib;ws2_32.lib;wldap32.lib;前两个是为了openssl,后两个是curl必须依赖的。</li></ol><p>在编译成功后curl-7.55.0-&gt;build-&gt;Win32-&gt;VC14-&gt;DLL DEBUG-DLL OpenSSL文件夹中会生成有libcurld.lib和libcurld.dll(注意名字不是libcurl)</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ol><li>创建一个控制台应用,例如项目名叫Test,在你的Test项目下创建include文件夹,将curl-7.55.0-&gt;include目录下的curl文件夹,复制过去。</li><li>新建lib文件夹,将libcurl编译的libcurld.dll和libcurld.lib复制到lib。</li><li>将libcurld.dll和之前OpenSSL生成的libeay32.lib、ssleay32.dll各复制一份到项目exe文件下,否则会报错。会提示定位不到序数,编译的过,运行不过。</li><li>选择配置属性-&gt;C/C++-&gt;预处理器-&gt;预处理器定义,添加CURL_STATICLIB。</li><li>属性中的附加包含目录，附加库目录都在代码实现</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&quot;curl/curl.h&quot;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#pragma comment(lib,&quot;libcurld.lib&quot;)</span><br><span class="line"></span><br><span class="line">size_t CallBack(void *ptr, size_t size, size_t nmemb, void *stream)</span><br><span class="line">&#123;</span><br><span class="line">    string *str = (string*)stream;</span><br><span class="line">    cout &lt;&lt; *str &lt;&lt; endl;</span><br><span class="line">    (*str).append((char*)ptr, size*nmemb);</span><br><span class="line">    return size * nmemb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    easy_global_init(CURL_GLOBAL_ALL);</span><br><span class="line"></span><br><span class="line">    CURL *curl=easy_curl_init();</span><br><span class="line">    if(curl)</span><br><span class="line">    &#123;</span><br><span class="line">        curl_easy_setopt(curl,CURLOPT_URL,&quot;www.baidu.com&quot;);</span><br><span class="line"></span><br><span class="line">        string result;</span><br><span class="line">        //设置ssl</span><br><span class="line">        curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, false);</span><br><span class="line">        curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, false);</span><br><span class="line">        //开启调式信息</span><br><span class="line">        curl_easy_setopt(curl, CURLOPT_VERBOSE, 1);</span><br><span class="line">        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, CallBack);</span><br><span class="line">        curl_easy_setopt(curl,CURLOT_WRITEDATA,(void *)&amp;result);</span><br><span class="line">        curl_easy_setopt(curl, CURLOPT_NOSIGNAL, 1);</span><br><span class="line">        curl_easy_setopt(curl,CURLOPT_TIMEOUT,3);</span><br><span class="line"></span><br><span class="line">        CURLcode res=curl_easy_perform(curl);</span><br><span class="line">        if(CURLE_OK!=res)</span><br><span class="line">        &#123;</span><br><span class="line">            cerr&lt;&lt;&quot;curl_easy_perform() failed&quot;&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Windows下编译libcurl和使用&quot;&gt;&lt;a href=&quot;#Windows下编译libcurl和使用&quot; class=&quot;headerlink&quot; title=&quot;Windows下编译libcurl和使用&quot;&gt;&lt;/a&gt;Windows下编译libcurl和使用&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="网络编程" scheme="http://www.thorns.cn/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="libcurl" scheme="http://www.thorns.cn/tags/libcurl/"/>
    
  </entry>
  
</feed>
