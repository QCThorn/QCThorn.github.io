<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Thorn&#39;s Blog</title>
  
  <subtitle>不卑不亢 一如初心 但行善事 莫顾前程</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.thorns.cn/"/>
  <updated>2018-12-27T08:17:07.785Z</updated>
  <id>http://www.thorns.cn/</id>
  
  <author>
    <name>Thorn</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>这么多年你一个人 一直在走</title>
    <link href="http://www.thorns.cn/2018/12/09/1208.html"/>
    <id>http://www.thorns.cn/2018/12/09/1208.html</id>
    <published>2018-12-09T03:21:40.000Z</published>
    <updated>2018-12-27T08:17:07.785Z</updated>
    
    <content type="html"><![CDATA[<h1 id="这么多年你一个人-一直在走"><a href="#这么多年你一个人-一直在走" class="headerlink" title="这么多年你一个人 一直在走"></a>这么多年你一个人 一直在走</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>恩，昨天某个逼让我失了声感冒了。中午起床极度不爽，得以于此，借深圳余温未散抽空记录一下生活。  </p></blockquote><p>&emsp;听他的歌时间不长，不到一年。忘记了从哪首开始，也不知道该在哪首结束。<br>&emsp;记忆中应该是在知晓了“祝星”这号人物的时候，才知道了“港岛妹妹”的西班牙馅饼。那段时间酷爱三毛笔下的西班牙，撒哈拉。也因此喜欢上了陈粒的《历历万乡》。不同于其它人对“港岛妹妹”的幻想，对“西班牙馅饼”的期待，我了解的“港岛妹妹”不过是某装逼犯的自淫，“西班牙馅饼”也不过是一张明信片。  </p><h2 id="你说你遇见了一大堆奇怪的人"><a href="#你说你遇见了一大堆奇怪的人" class="headerlink" title="你说你遇见了一大堆奇怪的人"></a>你说你遇见了一大堆奇怪的人</h2><p>&emsp;时光就这样悄悄的流走，早高峰 晚高峰，有身穿OL装的白领正拿着粉底盒涂抹着她那疲惫的妆容，有一张张放声大笑的脸努力汲取着手机上短视频的笑点，也有戴着耳机或是手拿一部kindle为考研，为四六级而准备的人群……像是厌倦了一切变得麻木，低头听歌，听歌抬头，抬头下车。忽然在某一早晨，耳边隐约回响起一句“这么多年你一个人，一直在走，你说你遇见了一大堆奇怪的人，他们看上去好像都比你开心。”至此我明白，在那一座六朝古都，那座为一人种满了梧桐的城市，有一个独立的灵魂用它那低沉，嘶吼的声音在我耳边激荡盘旋，不能离去。从此，喜欢李志的歌一发不可收拾。</p><h2 id="他们指向左，他们指向右"><a href="#他们指向左，他们指向右" class="headerlink" title="他们指向左，他们指向右"></a>他们指向左，他们指向右</h2><p>&emsp;有人说不能常听他的歌，会变得浑身充满负能量的人。对于这种说法，我身边的一位朋友，告诉我他“每天都是靠这逼的歌坚持下去的”，他的歌充满意义，带有思考。哈哈哈，写在这里的时候，真…<br>关于这首歌还是不提为好。有想研究的自个研究去。  </p><p><img src="/images/李志.jpeg" alt="avatar"></p><a id="more"></a><h2 id="这个世界会好的"><a href="#这个世界会好的" class="headerlink" title="这个世界会好的"></a>这个世界会好的</h2><p>昨天他的压轴，一出场全场齐呼“逼哥牛逼，逼哥牛逼”！第一眼看到真人，一顶老旧的灰色帽子，一件老旧的灰色短袖(出发的时候朋友叫我带衣服，嫌麻烦没带，这两天深圳满30减15的温度活动不得不说很商业化，但看到他穿着一件短袖，“牛逼”！),一条老旧的蓝色牛仔，跟每天在视频上看到的并无差别。跟上面的图片搭配一模一样，心中不禁想这套衣服多久没换了？还好牙齿洗了。旁边的一位，额 怎么来形容呢，对于年龄比自己的大的吧 叫一声美女显得轻浮，说叫一个女人吧显得又太不会用词。那就叫旁边的一位可爱的女孩吧。《逃避可耻却有用》里面讲“可爱是最高级的形容词”，说的真对。一直在哪欢呼，在台底下跟逼哥抬扛，逼哥唱到“妈妈”的时候，她吼“恩，我在这里”，说到“一根烟的时候”，她回“是两根”，很喜欢这种氛围。全程一个小时下来，逼哥在结束开启了他的逼言逼语，后面的旗子挥舞着一个”B”字。他讲40年来改革开放，讲我们应该要谢谢，要学会感恩。嗯，这个世界会好的。</p><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>他就是b言b语，五块钱的发型，老套的衣服，一口大黄牙。却让人不反感，你知道他开始装逼了，听完了。你甚至都想去买两包南京(九五之尊)给他点着，既然这次没机会给你散烟，那就劳驾我拉着我的基友亲自去热河给你散一根南京的南京吧。   </p><p>朋友对我刁侃道:你走在宋美龄大道上风花雪月，我走在义和五龙街感叹人生  </p><p>我回:不是因为六朝古都，不是因为哪座种满了梧桐的城市。<br>我带你去南京听热河，带你去武林门听杭州。<br>自带装逼属性有没有！<br><img src="/images/1.jpeg" alt="avatar"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;这么多年你一个人-一直在走&quot;&gt;&lt;a href=&quot;#这么多年你一个人-一直在走&quot; class=&quot;headerlink&quot; title=&quot;这么多年你一个人 一直在走&quot;&gt;&lt;/a&gt;这么多年你一个人 一直在走&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;恩，昨天某个逼让我失了声感冒了。中午起床极度不爽，得以于此，借深圳余温未散抽空记录一下生活。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;emsp;听他的歌时间不长，不到一年。忘记了从哪首开始，也不知道该在哪首结束。&lt;br&gt;&amp;emsp;记忆中应该是在知晓了“祝星”这号人物的时候，才知道了“港岛妹妹”的西班牙馅饼。那段时间酷爱三毛笔下的西班牙，撒哈拉。也因此喜欢上了陈粒的《历历万乡》。不同于其它人对“港岛妹妹”的幻想，对“西班牙馅饼”的期待，我了解的“港岛妹妹”不过是某装逼犯的自淫，“西班牙馅饼”也不过是一张明信片。  &lt;/p&gt;
&lt;h2 id=&quot;你说你遇见了一大堆奇怪的人&quot;&gt;&lt;a href=&quot;#你说你遇见了一大堆奇怪的人&quot; class=&quot;headerlink&quot; title=&quot;你说你遇见了一大堆奇怪的人&quot;&gt;&lt;/a&gt;你说你遇见了一大堆奇怪的人&lt;/h2&gt;&lt;p&gt;&amp;emsp;时光就这样悄悄的流走，早高峰 晚高峰，有身穿OL装的白领正拿着粉底盒涂抹着她那疲惫的妆容，有一张张放声大笑的脸努力汲取着手机上短视频的笑点，也有戴着耳机或是手拿一部kindle为考研，为四六级而准备的人群……像是厌倦了一切变得麻木，低头听歌，听歌抬头，抬头下车。忽然在某一早晨，耳边隐约回响起一句“这么多年你一个人，一直在走，你说你遇见了一大堆奇怪的人，他们看上去好像都比你开心。”至此我明白，在那一座六朝古都，那座为一人种满了梧桐的城市，有一个独立的灵魂用它那低沉，嘶吼的声音在我耳边激荡盘旋，不能离去。从此，喜欢李志的歌一发不可收拾。&lt;/p&gt;
&lt;h2 id=&quot;他们指向左，他们指向右&quot;&gt;&lt;a href=&quot;#他们指向左，他们指向右&quot; class=&quot;headerlink&quot; title=&quot;他们指向左，他们指向右&quot;&gt;&lt;/a&gt;他们指向左，他们指向右&lt;/h2&gt;&lt;p&gt;&amp;emsp;有人说不能常听他的歌，会变得浑身充满负能量的人。对于这种说法，我身边的一位朋友，告诉我他“每天都是靠这逼的歌坚持下去的”，他的歌充满意义，带有思考。哈哈哈，写在这里的时候，真…&lt;br&gt;关于这首歌还是不提为好。有想研究的自个研究去。  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/李志.jpeg&quot; alt=&quot;avatar&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Life" scheme="http://www.thorns.cn/categories/Life/"/>
    
    
  </entry>
  
  <entry>
    <title>traits编程技法</title>
    <link href="http://www.thorns.cn/2018/08/31/traits%E7%BC%96%E7%A8%8B%E6%8A%80%E6%B3%95.html"/>
    <id>http://www.thorns.cn/2018/08/31/traits编程技法.html</id>
    <published>2018-08-31T04:06:20.000Z</published>
    <updated>2018-08-30T16:10:17.468Z</updated>
    
    <content type="html"><![CDATA[<h1 id="STL之traits编程技法的理解"><a href="#STL之traits编程技法的理解" class="headerlink" title="STL之traits编程技法的理解"></a>STL之traits编程技法的理解</h1><blockquote><p>注:很多内容节选自《STL源码剖析》,见上自己的理解，特此记录   </p></blockquote><ul><li>traits又被叫做”特性萃取技术”,用于提取被”被传进来的对象对应的返回类型,让同一个接口实现对应的功能。因为STL的算法和容器是分离的,两者通过迭代器连接,算法的实现并不知道传进来的是什么,萃取器相当于接口和实现之间加一层封装,来隐藏一些细节并协助调用合适的方法。<h2 id="迭代器的类型"><a href="#迭代器的类型" class="headerlink" title="迭代器的类型"></a>迭代器的类型</h2>我们知道迭代器有五种类型,分别是    </li></ul><ol><li>value_type(迭代器所指对象的类型)</li><li>difference_type(用来表示两个迭代器之间的距离)</li><li>reference_type(迭代器所指对象的引用)</li><li>point_type(迭代器所指的对象)</li><li>iterator_category(标识迭代器的移动特性和可以对迭代器进行的操作,大致可以分为五类)<br> Input iterator<br> Output iterator<br> Forward iterator<br> Bidirectional iterator<br> Random Access iterator     </li></ol><h2 id="声明内嵌型别"><a href="#声明内嵌型别" class="headerlink" title="声明内嵌型别"></a>声明内嵌型别</h2><p>考虑一下，当我们需要实现某个函数时,且该函数的返回类型必须是value_type是，该怎么办？我们不能使用”template 参数推导机制”,毕竟推导机制推导的是参数，无法推导函数的返回值型别。<br>在这里我们就可以用到声明内嵌型别,来解决使用value_type用于函数的返回类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class T&gt;</span><br><span class="line">struct MyIter&#123;</span><br><span class="line">  typedef T value_type;     //内嵌型别声明</span><br><span class="line">  MyIter(T *p=0):ptr(p) &#123;&#125;</span><br><span class="line">  T&amp; operator*() const &#123;return *ptr;&#125;</span><br><span class="line">  private:</span><br><span class="line">    T *ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//使用value_type用于函数返回类型</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">typename I::value_type func(I ite)</span><br><span class="line">&#123;</span><br><span class="line">    return *ite;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//...</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Myiter&lt;int&gt; ite(new int(8));</span><br><span class="line">    cout&lt;&lt;func(ite)&lt;&lt;endl;  //输出:8</span><br><span class="line">&#125;</span><br><span class="line">```   </span><br><span class="line">func函数中的typename用意是在告诉编译器I::value_type是一个型别,因为T是一个template参数,在它被编译器具现化之前,编译器对T一无所悉,编译器不知道I::value_type代表的是一个型别还是一个member function或者是data member。   </span><br><span class="line">这样看起来结局了我们的问题,但是有个隐晦的陷阱:并不是所有的迭代器都是class type。原生指针就不是,如果不是class type,就无法为它定义内嵌型别。有没有好的解决办法呢？偏特化可以为我们解决这个问题。</span><br><span class="line">## 模板偏特化</span><br><span class="line">《STL源码剖析》一书上对模板偏特化的意义大致解释是:</span><br><span class="line">&gt; 如果class template拥有一个以上的template参数,我们可以针对其中某个(或数个,但非全部)template参数进行特化工作。换句话说,我们可以在泛化设计中提供一个特化版本。</span><br></pre></td></tr></table></figure></p><p>//萃取器<br>template <class i=""><br>struct iterator_traits{<br>  typedef typename T I::value_type value_type;<br>};</class></p><p>//偏特化版<br>template <class t=""><br>struct ierator_traits&lt;T*&gt;{<br>  typedef T value_type;<br>};</class></p><p>//偏特化过后的func函数<br>template <class t=""><br>typename iterator_traits<i>::value_type //这一整行是函数返回型别<br>func(I ite)<br>{<br>    return *ite;<br>}</i></class></p><p>int main()<br>{<br>    int a=8;<br>    int <em>p=&a;<br>    cout&lt;&lt;func(p)&lt;&lt;endl;    //传的类型是int</em><br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">上面我们通过偏特化版就可以获取原始指针的型别用来定义函数返回型别,可能会问如果原始指针是个pointer-to-const怎么办呢？没关系再偏特化一个版本就好了</span><br></pre></td></tr></table></figure><p>template <class t=""><br>struct iterator_traits<const t*="">{<br>  typedef T value_type;<br>};<br><code>`</code><br>以上就是stl中使用的traits技法，traits就像一台”特性萃取机”,萃取各个迭代器的相应型别。</const></class></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;STL之traits编程技法的理解&quot;&gt;&lt;a href=&quot;#STL之traits编程技法的理解&quot; class=&quot;headerlink&quot; title=&quot;STL之traits编程技法的理解&quot;&gt;&lt;/a&gt;STL之traits编程技法的理解&lt;/h1&gt;&lt;blockquote&gt;

      
    
    </summary>
    
      <category term="STL源码剖析" scheme="http://www.thorns.cn/categories/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
    
      <category term="STL traits" scheme="http://www.thorns.cn/tags/STL-traits/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu安装Mongodb及配置</title>
    <link href="http://www.thorns.cn/2018/08/23/ubuntu%E5%AE%89%E8%A3%85Mongodb%E5%8F%8A%E9%85%8D%E7%BD%AE.html"/>
    <id>http://www.thorns.cn/2018/08/23/ubuntu安装Mongodb及配置.html</id>
    <published>2018-08-23T02:58:20.000Z</published>
    <updated>2018-08-24T04:10:58.680Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ubuntu安装Mongodb及配置"><a href="#ubuntu安装Mongodb及配置" class="headerlink" title="ubuntu安装Mongodb及配置"></a>ubuntu安装Mongodb及配置</h1><p>官方下载地址: <a href="https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-amazon2-4.0.1.tgz" target="_blank" rel="noopener">https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-amazon2-4.0.1.tgz</a>  </p><p>使用curl进行下载<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -O https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-amazon2-4.0.1.tgz</span><br></pre></td></tr></table></figure></p><p>解压<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf mongodb-linux-x86_64-ubuntu1404-4.0.1.tgz</span><br></pre></td></tr></table></figure></p><p>移动到用户local目录下(可自定义)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mv mongodb-linux-x86_64-ubuntu1404-4.0.1.tgz /usr/local/mongodb</span><br></pre></td></tr></table></figure></p><p>创建数据库目录和日志目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /data/db</span><br><span class="line">sudo mkdir /data/logs</span><br></pre></td></tr></table></figure></p><p>创建配置文件,启动mongod时需要<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/local/mongodb/bin/mongodb.conf #将配置文件放在mongodb/bin目录下</span><br><span class="line"></span><br><span class="line">dbpath=/data/db/    #db路径</span><br><span class="line">logpath=/data/logs/mongodb.log  #log路径</span><br><span class="line">fork=true   #以后台模式mongos进程  </span><br><span class="line">port=27017</span><br></pre></td></tr></table></figure></p><p>配置mongodb环境变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bashrc</span><br><span class="line">#在最后添加</span><br><span class="line">export PATH=$PATH:/usr/local/mongodb/bin</span><br><span class="line">#退出使用source命令使设置生效</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure></p><p>接下来就可以开启mongodb服务了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mongod -f /usr/local/mongodb/bin/mongodb.conf</span><br><span class="line">#使用mongo连接服务</span><br><span class="line">mongo</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ubuntu安装Mongodb及配置&quot;&gt;&lt;a href=&quot;#ubuntu安装Mongodb及配置&quot; class=&quot;headerlink&quot; title=&quot;ubuntu安装Mongodb及配置&quot;&gt;&lt;/a&gt;ubuntu安装Mongodb及配置&lt;/h1&gt;&lt;p&gt;官方下载地址
      
    
    </summary>
    
      <category term="Mongodb" scheme="http://www.thorns.cn/categories/Mongodb/"/>
    
    
      <category term="Mongodb" scheme="http://www.thorns.cn/tags/Mongodb/"/>
    
  </entry>
  
  <entry>
    <title>谈谈ss和socks5协议</title>
    <link href="http://www.thorns.cn/2018/05/06/%E8%B0%88%E8%B0%88socks5%E5%8D%8F%E8%AE%AE%E5%92%8Css.html"/>
    <id>http://www.thorns.cn/2018/05/06/谈谈socks5协议和ss.html</id>
    <published>2018-05-06T08:12:32.000Z</published>
    <updated>2018-05-06T08:20:28.008Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ss和socks5协议"><a href="#ss和socks5协议" class="headerlink" title="ss和socks5协议"></a>ss和socks5协议</h1><blockquote><p>本文首发于个人博客:<a href="http://www.thorns.cn">www.thorns.cn</a></p></blockquote><p>前言:由于最近公司需要一个自己的代理服务,所以花了一周的时间去研究了下shadowsocks实现的原理,以及socks5协议。</p><h1 id="认识Shadowsocks"><a href="#认识Shadowsocks" class="headerlink" title="认识Shadowsocks"></a>认识Shadowsocks</h1><p>Shadowsocks是一个能骗过GFW的网络代理工具,它把我们要访问的数据请求,比如google,youtube，facebook…进行加密后传输到GFW外的服务端,由服务端去访问目标站点再加密返回给我们,网络中的GFW由于不知道传输的原内容是什么只好放行,于是就完成了我们所谓的”翻墙”。  </p><h1 id="Shadowsocks原理"><a href="#Shadowsocks原理" class="headerlink" title="Shadowsocks原理"></a>Shadowsocks原理</h1><p>SS(Shadowsocks)由两部分组成,运行在本地的ss-local和防火墙之外服务器上的ss-server。ss-local的职责是在本机启动和监听一个服务,本地软件的网络请求都会先发送到ss-local,ss-local收到来自本地软件的网络请求后,把要传输的原数据根据用户配置的加密方法和密码进行加密,再转发到服务端。ss-server的职责是在墙外服务器启动和监听一个服务,当服务端收到ss-local转发过来的数据时,会根据用户配置的加密方法和密码对数据进行解密,同时还会解socks5协议，然后会把解密后的数据转发到真正的请求目标服务地址(例如Google),以下是整个流程图.<br><img src="/images/liucheng.png" alt="avatar"></p><h1 id="Socks5协议介绍"><a href="#Socks5协议介绍" class="headerlink" title="Socks5协议介绍"></a>Socks5协议介绍</h1><p>SS的数据传输是建立在socks5协议之上的，Socks5是TCP/IP的网络代理协议，socks5有协商认证请求部分,个人更喜欢把他叫做Protocol Handshake。</p><h2 id="协商版本和验证方法"><a href="#协商版本和验证方法" class="headerlink" title="协商版本和验证方法"></a>协商版本和验证方法</h2><p>当我们的客户端向服务端建立连接之后,客户端就会向服务端进行协商,发送的数据包如下:<br><img src="/images/xs.png" alt="avatar"></p><p>其中各字段的含义如下:<br>VER:代表SOCKS的版本,SOCKS5 默认为0x05,固定长度一个字节。<br>NMETHODS:表示第三个字段的长度(也就是有几种认证方法),长度也是一个字节<br>METHODS:表示客户端支持的验证方式,可以有多种,长度1-255字节。<br>支持的验证方式有:  </p><ul><li>0x00:NO AUTHENTICATION REQUIRED（不需要验证）  </li><li>0x01:GSSAPI (通用安全服务应用程序接口)  </li><li>0x02:USERNAME/PASSWD(用户名密码)  </li><li>0x03:IANA ASSIGNED(至 0x’7F’ IANA 分配)</li><li>0x80:RESERVED FOR PRIVATE METHODS(至 0x’FE’ 私人方法保留)  </li><li>0xff:NO ACCEPTABLE METHODS(没有可接受的方法)<br>当服务端收到客户端的验证机信息之后，就要回应客户端提供哪种验证方式的信息。服务端回应的包格式如下:<br><img src="/images/xs1.png" alt="avatar"></li><li>VER:代表SOCKS的版本,SOCKS5默认为0x05,长度一个字节。  </li><li>METHOD:代表服务端回应客户端需要哪种验证方式,可以为上面六种验证方式之一   </li></ul><p>举个例子,比如客户端发送的包是 0x05 0x01 0x02，如果服务端不需要验证就会返回0X05 0X00,需要验证就会返回0x05 0x02,接下来客户端就需要进行认证这一步，也就是把用户名和密码发送给服务端进行认证,在这里我就不介绍认证这一步了,直接说请求这一步。</p><h2 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h2><p>客户端发起的连接由服务端验证通过后,客户端下一步就应该把要访问的目的网站地址给服务端,服务端得到地址后再去请求真正的目标服务。这一步客户端需要发送的包格式如下:<br><img src="/images/re.png" alt="avatar"></p><p>各个字段含义如下:</p><ul><li>VER:socks的版本  </li><li>CMD:代表客户端请求的类型，值长度1个字节,有三种类型:  <ol><li>Connect: 0x01  </li><li>BIND: 0x02</li><li>UDP: 0x03</li></ol></li><li>RSV:保留字段,默认0x00,长度1个字节</li><li>ATYP:代表请求的远程服务器地址类型,长度1个字节，三种类型:<ol><li>IPV4: 0x01</li><li>IPV6: 0x04</li><li>DOMAINNAME: 0x03</li></ol></li><li>DST.ADDR:代表远程服务器的地址,根据ATYP进行解析,值长度不定  </li><li>DST.PORT:代表远程服务器的端口,值长度2个字节</li></ul><p>服务端再收到客户端告诉的目标服务地址后，便和目标进行连接,不管成功与否,服务器都应该把连接的结果告诉客户端.如果连接成功的情况下,服务端返回的包格式如下:<br><img src="/images/sre.png" alt="avatar"></p><p>各个字段含义如下:</p><ul><li>REP:代表响应码,值长度1个字节，有如下类型<ol><li>0x00:succeeded(成功)</li><li>0x01:general SOCKS server failure(socks5服务器失败)</li><li>0x02:connection not allowed by ruleset</li><li>0x03:Network unreachable(网络无法访问)</li><li>0x04:Host unreachable(主机无法访问)</li><li>0x05:Connection refused(拒绝连接)</li><li>0x06:TTL expired(TTL 超时)</li><li>0x07:Command not supported(命令不支持)</li><li>0x08:Address type not supported(地址类型不受支持)</li><li>0x09:to 0xFF unassigned</li></ol></li><li>RSV:保留字,值长度一字节  </li><li>BND.ADDR:表示绑定地址,值长度不定  </li><li>BND.PORT:表示绑定端口,值长度2字节  </li></ul><h2 id="数据转发"><a href="#数据转发" class="headerlink" title="数据转发"></a>数据转发</h2><p>客户端在收到来自服务器成功的响应后，就会开始发送数据给本地代理，本地代理加密后进行转发给服务端,服务端解密之后访问最终目标服务。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>SOCKS5协议的目的就是为了把原本应该在本机直接请求目标服务的流程,放到了服务端去代理 客户端访问.运行流程如下:</p><p>本地代理和服务端协商认证请求<br>本地代理告诉服务端目标服务的地址<br>服务端去访问目标服务,成功后告诉本地代理<br>本机开始发送原本应发送到目标服务的数据给服务端,由服务端完成数据转发  </p><p>注:以上内容有很多部分都是参考RFC1928,和其他博主发表的博文，借鉴而来。如果感觉有什么地方不对或者不同见解的，都可以提出争议,以立即改正。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ss和socks5协议&quot;&gt;&lt;a href=&quot;#ss和socks5协议&quot; class=&quot;headerlink&quot; title=&quot;ss和socks5协议&quot;&gt;&lt;/a&gt;ss和socks5协议&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本文首发于个人博客:&lt;a href=&quot;ht
      
    
    </summary>
    
      <category term="网络编程" scheme="http://www.thorns.cn/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="socks" scheme="http://www.thorns.cn/tags/socks/"/>
    
  </entry>
  
  <entry>
    <title>More Effective C++ 8:new和delete</title>
    <link href="http://www.thorns.cn/2018/05/03/new.html"/>
    <id>http://www.thorns.cn/2018/05/03/new.html</id>
    <published>2018-05-02T20:04:44.000Z</published>
    <updated>2018-12-09T05:30:05.040Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>最近在看侯捷译的More Effective C++,看的过程有不少收获,发现自己对C++很多地方其实没有过多去了解,收获很多,记录一下。</p></blockquote><h1 id="三种new和delete"><a href="#三种new和delete" class="headerlink" title="三种new和delete"></a>三种new和delete</h1><p>我们知道,new和delete都是C++里的关键字,同时也是操作符。new负责分配内存，delete释放内存。new和delete都有new operator、operator new，placement new，delete operator。下面分别介绍这几种操作</p><h2 id="new-operator和delete-operator"><a href="#new-operator和delete-operator" class="headerlink" title="new operator和delete operator"></a>new operator和delete operator</h2><p>new operator和delete operator就是我们经常使用的new和delete,这两个操作符是由语言内建的,就像sizeof操作符一样，不能被改变意义。当我们写出这样的代码时new operatorf和new delete在执行时分为两步:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string *ps=new string(&quot;new operator&quot;);</span><br><span class="line">delete ps;</span><br></pre></td></tr></table></figure><ol><li>new operator 会先执行分配内存的操作,它会调用一个只分配内存的函数,这个函数就是operator new,它分配足够的内存，用来放置对象。new delete在释放内存前，会先调用对象的析构函数.</li><li>当new operator分配完内存的时候,它会调用一个构造函数,为刚才分配的内存中的对象设定初值。而delete operator调用完析构函数时,它会调用一个释放内存的函数 operator delete,这时候才会释放对象所占用的内存。</li></ol><p>以上两行代码，拆分开来就是这样,先调用构造函数,分配内存，调用析构函数，释放内存,在编译器中的操作如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void *memory=operator new(sizeof(string)); //取得原始内存</span><br><span class="line">call string::string(&quot;Memory Management&quot;) on*memory;//将内存中的对象初始化</span><br><span class="line">string *ps=static_cast&lt;string*&gt;(memory)；</span><br></pre></td></tr></table></figure><ul><li>注意new operator 和new delete都不可以被重载。</li></ul><h2 id="operator-new和operator-delete"><a href="#operator-new和operator-delete" class="headerlink" title="operator new和operator delete"></a>operator new和operator delete</h2><p>上面一直说到new和delete其实在内部都会调用到这两个函数，这两个函数到底跟new和delete有什么区别呢？通常operator new ,operator delete声明如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void *ps=operator new(sizeof(string));</span><br><span class="line">operator delete(ps);</span><br></pre></td></tr></table></figure><h2 id="placement-new-定位new"><a href="#placement-new-定位new" class="headerlink" title="placement new(定位new)"></a>placement new(定位new)</h2><blockquote><p>写这篇文章,其实主要是写这个用法，还记得看到这个用法的时候，是在侯捷翻译的另一本书《STL 源码剖析》在讲空间配置器时看见的。</p></blockquote><p>placement new是operator new的一种特殊版本,也是new operator的另一种用法,在已分配的内存上构造对象。要使用placement new必须要包含头文件new,#include或者#include&lt;new.h&gt;,调用示例就直接用书上的了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Widget</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Widget(int widgetSize);</span><br><span class="line">&#125;;</span><br><span class="line">Widget *constructWidgetInBuffer(void *buffer,int widgetSize)</span><br><span class="line">&#123;</span><br><span class="line">    return new(buffer) Widget(widgetSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此函数返回指针,指向一个Widget对象,它被构造于传递给此函数的一块内存缓冲区上。在函数内部唯一的表达式就是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new (buffer) Widget(widgetSize);</span><br></pre></td></tr></table></figure><p>于是,在buffer指向的这边空间，就构造了一个Widget对象。</p><p>注意,如果你使用了placement new，在某块内存中产生对象,应该避免对那块内存使用delete operator。因为这个delete operator会调用operator delete来释放内存,但是该内存内含的对象最初并非是由operator new分配得来的,毕竟placement new只是返回它所接受的指针而已,应该直接调用该对象的析构,然后在释放内存。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void *mallocShared(size_t size);</span><br><span class="line">void freeShared(void *memory);</span><br><span class="line">void *sharedMemory=mallocShared(sizeof(Widget));</span><br><span class="line">Widget *pw=constructWidgeInBuffer(sharedMemory,10);//placement new用法</span><br><span class="line">...</span><br><span class="line">delete pw;//错。sharedMemory来自mallocShared，不是来自operator new</span><br><span class="line">pw.~Widget();  //可以，析构pw所指的Widget对象,但并未释放Widget占用的内存</span><br><span class="line">freeShared(pw);  //可以,释放pw所指的内存,不调用任何析构函数</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;最近在看侯捷译的More Effective C++,看的过程有不少收获,发现自己对C++很多地方其实没有过多去了
      
    
    </summary>
    
      <category term="More Effective C++" scheme="http://www.thorns.cn/categories/More-Effective-C/"/>
    
    
      <category term="More Effective C++" scheme="http://www.thorns.cn/tags/More-Effective-C/"/>
    
  </entry>
  
  <entry>
    <title>Windows下编译libcurl和使用</title>
    <link href="http://www.thorns.cn/2018/04/01/Windows%E4%B8%8B%E7%BC%96%E8%AF%91libcurl.html"/>
    <id>http://www.thorns.cn/2018/04/01/Windows下编译libcurl.html</id>
    <published>2018-04-01T15:47:44.000Z</published>
    <updated>2018-05-06T07:38:54.864Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Windows下编译libcurl和使用"><a href="#Windows下编译libcurl和使用" class="headerlink" title="Windows下编译libcurl和使用"></a>Windows下编译libcurl和使用</h1><blockquote><p>之前在Linux下使用过wget和curl,感觉使用起来都很简单,没什么困难之处,最近在windows下要使用libcurl,编译和使用的时候踩了不少坑,特此记录一下。</p></blockquote><h1 id="认识libcurl"><a href="#认识libcurl" class="headerlink" title="认识libcurl"></a>认识libcurl</h1><p>libcurl是一个跨平台的开源的网络协议库,它支持http,https，ftp,telnet等协议,同样它支持https证书授权,使用起来简便不像其他的网络库一样复杂,想要知道更多关于libcurl的介绍,可以到官网<a href="https://cur.heaxx.se上去了解,在这里不做过多介绍。" target="_blank" rel="noopener">https://cur.heaxx.se上去了解,在这里不做过多介绍。</a></p><h1 id="编译libcurl"><a href="#编译libcurl" class="headerlink" title="编译libcurl"></a>编译libcurl</h1><p>在编译libcurl之前,需要先做如下配置</p><h2 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h2><ul><li>libcurl去官网下载源码 博主自己用的是curl-7.55.0 <a href="https://curl.haxx.se/download/curl-7.55.0.zip" target="_blank" rel="noopener">https://curl.haxx.se/download/curl-7.55.0.zip</a></li><li>openssl,下载openssl-1.0.2k,1.1.0以后的文件安装方法都换了 <a href="https://www.openssl.org/source/" target="_blank" rel="noopener">https://www.openssl.org/source/</a></li><li>下载perl解析器,编译依赖库openssl的时候需要用到<a href="https://www.activestate.com/activeperl/downloads" target="_blank" rel="noopener">https://www.activestate.com/activeperl/downloads</a></li><li>zlib下载1.2.11 <a href="http://zlib.net" target="_blank" rel="noopener">http://zlib.net</a></li></ul><h3 id="配置目录"><a href="#配置目录" class="headerlink" title="配置目录"></a>配置目录</h3><p>为了不愿跟博主一样再踩过很多坑以后，才编译成功,在你的盘符根目录下新建一个文件夹名叫libcurl-ssl,将下载的三个压缩包解压到该目录。</p><h3 id="ActiveState安装"><a href="#ActiveState安装" class="headerlink" title="ActiveState安装:"></a>ActiveState安装:</h3><p>执行安装程序,默认安装路径或者自定义路径都可以。</p><h3 id="zlib编译"><a href="#zlib编译" class="headerlink" title="zlib编译"></a>zlib编译</h3><ol><li>在你创建的文件夹下打开zlib-1.2.11\contrib\vstudio\vc14\zlibvc.sln,选择编译release版本,平台x86,x64自选。</li><li>编译过后,会在x86或者x64文件夹下的ZlibDllRelease文件夹中生成zlibwapi.dll和zlibwapi.lib文件</li></ol><h3 id="openssl编译"><a href="#openssl编译" class="headerlink" title="openssl编译"></a>openssl编译</h3><p>这一步算是比较麻烦,也容易出错的地方,因为只能通过命令行来进行编译</p><ol><li>在开始菜单中找到自带的vs本机工具命令提示符,你的vs版本 和要进行编译的平台自己选择。我用的是vs2015 x86</li><li>使用cd命令进入到你创建的文件夹下的openssl-1.0.2k中</li><li>命令行输入perl Configure VC-WIN32 no-asm</li><li>命令行输入ms\do_ms.bat</li><li>命令行输入nmake -f ms/ntdll.mak</li></ol><p>耐心等待编译结束,抽根烟回来就编译好了,查看编译过程只要不出现”stop”,”error”的,就算成功了,如果出现错误的话,最好是把整个文件夹删了，重新解压编译,如果留有编译失败的文件，再进行编译的话它可能会提示”无法解析xxx”。</p><p>接着将openssl-1.0.2k-&gt;inc32-&gt;openssl中所有的.h文件和openssl-1.0.2k-&gt;out32dll中的libeay32.lib、libeay32.dll、ssleay32.lib、ssleay32.dll一起复制到curl-7.55.0-&gt;lib-&gt;opensll中，如果lib文件夹下没有openssl,建立一个就可以了。</p><h3 id="libcurl编译"><a href="#libcurl编译" class="headerlink" title="libcurl编译"></a>libcurl编译</h3><p>libcurl直接使用vs进行编译,编译平台选择DLL DEBUG-DLL OpenSSL</p><ol><li>打开curl-7.55.0-&gt;projects-&gt;Windows-&gt;VC14-&gt;curl-all.sln,可能vs会提示升级工程，确定即可。</li><li>将libcurl设为启动项目,将libcurl的资源文件libcurl.rc移出。</li><li>右键项目选择属性-&gt;C/C++-&gt;预处理器-&gt;预处理器定义,将”BUILDING_LIBCURL”改成”CURL_STATICLIB”。接口函数不会被声明为导出函数</li><li>选择属性-&gt;链接器-&gt;输入-&gt;附加依赖项添加 libeay32.lib;ssleay32.lib;ws2_32.lib;wldap32.lib;前两个是为了openssl,后两个是curl必须依赖的。</li></ol><p>在编译成功后curl-7.55.0-&gt;build-&gt;Win32-&gt;VC14-&gt;DLL DEBUG-DLL OpenSSL文件夹中会生成有libcurld.lib和libcurld.dll(注意名字不是libcurl)</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ol><li>创建一个控制台应用,例如项目名叫Test,在你的Test项目下创建include文件夹,将curl-7.55.0-&gt;include目录下的curl文件夹,复制过去。</li><li>新建lib文件夹,将libcurl编译的libcurld.dll和libcurld.lib复制到lib。</li><li>将libcurld.dll和之前OpenSSL生成的libeay32.lib、ssleay32.dll各复制一份到项目exe文件下,否则会报错。会提示定位不到序数,编译的过,运行不过。</li><li>选择配置属性-&gt;C/C++-&gt;预处理器-&gt;预处理器定义,添加CURL_STATICLIB。</li><li>属性中的附加包含目录，附加库目录都在代码实现</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&quot;curl/curl.h&quot;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#pragma comment(lib,&quot;libcurld.lib&quot;)</span><br><span class="line"></span><br><span class="line">size_t CallBack(void *ptr, size_t size, size_t nmemb, void *stream)</span><br><span class="line">&#123;</span><br><span class="line">    string *str = (string*)stream;</span><br><span class="line">    cout &lt;&lt; *str &lt;&lt; endl;</span><br><span class="line">    (*str).append((char*)ptr, size*nmemb);</span><br><span class="line">    return size * nmemb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    easy_global_init(CURL_GLOBAL_ALL);</span><br><span class="line"></span><br><span class="line">    CURL *curl=easy_curl_init();</span><br><span class="line">    if(curl)</span><br><span class="line">    &#123;</span><br><span class="line">        curl_easy_setopt(curl,CURLOPT_URL,&quot;www.baidu.com&quot;);</span><br><span class="line"></span><br><span class="line">        string result;</span><br><span class="line">        //设置ssl</span><br><span class="line">        curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, false);</span><br><span class="line">        curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, false);</span><br><span class="line">        //开启调式信息</span><br><span class="line">        curl_easy_setopt(curl, CURLOPT_VERBOSE, 1);</span><br><span class="line">        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, CallBack);</span><br><span class="line">        curl_easy_setopt(curl,CURLOT_WRITEDATA,(void *)&amp;result);</span><br><span class="line">        curl_easy_setopt(curl, CURLOPT_NOSIGNAL, 1);</span><br><span class="line">        curl_easy_setopt(curl,CURLOPT_TIMEOUT,3);</span><br><span class="line"></span><br><span class="line">        CURLcode res=curl_easy_perform(curl);</span><br><span class="line">        if(CURLE_OK!=res)</span><br><span class="line">        &#123;</span><br><span class="line">            cerr&lt;&lt;&quot;curl_easy_perform() failed&quot;&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Windows下编译libcurl和使用&quot;&gt;&lt;a href=&quot;#Windows下编译libcurl和使用&quot; class=&quot;headerlink&quot; title=&quot;Windows下编译libcurl和使用&quot;&gt;&lt;/a&gt;Windows下编译libcurl和使用&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="网络编程" scheme="http://www.thorns.cn/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="libcurl" scheme="http://www.thorns.cn/tags/libcurl/"/>
    
  </entry>
  
</feed>
