<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一如初心</title>
  
  <subtitle>奔跑 跌倒 奔跑</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://thorns.cn/"/>
  <updated>2020-07-08T16:15:26.962Z</updated>
  <id>https://thorns.cn/</id>
  
  <author>
    <name>Thorn</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>聚散终有时，感谢相遇</title>
    <link href="https://thorns.cn/2020/07/09/%E8%81%9A%E6%95%A3%E7%BB%88%E6%9C%89%E6%97%B6%EF%BC%8C%E6%84%9F%E8%B0%A2%E7%9B%B8%E9%81%87.html"/>
    <id>https://thorns.cn/2020/07/09/聚散终有时，感谢相遇.html</id>
    <published>2020-07-08T16:14:05.000Z</published>
    <updated>2020-07-08T16:15:26.962Z</updated>
    
    <content type="html"><![CDATA[<h3 id="聚散终有时，感谢相遇"><a href="#聚散终有时，感谢相遇" class="headerlink" title="聚散终有时，感谢相遇"></a>聚散终有时，感谢相遇</h3><blockquote><p>浪潮来临时，没有一粒尘埃可以在浪花下避免。</p></blockquote><p>&emsp;曾设想过一个问题，万一有一天我被裁了会怎么办？当时心中的答案是 “在路上”，背着一个背包，去各地流浪，想到此</p><p>心中不免有一些愉悦和期待那一天的到来……</p><p>&emsp;可当这一天来临时，终究还是不舍。</p><p>&emsp;下午，老板找我聊了一会儿，告诉我是时候该说“道别的时候了”。回想起，去年这个时候，刚好也是我向老板提出离职请求，理由我并没有隐瞒——自己不太适合公司如今的项目，要去新疆骑行。犹记得那段谈话 “去吧，不用离职，给你批假，放松好了再回来上班，项目不合适等你回来后，给你换其它项目试试”。此去就是一月，回来后老板还跟我谈起这段旅程，也是从那时候我知道，原来我老板也是个性情中人，在他创业前，也曾单枪匹马的骑过川藏。来了兴趣，除了工作关系外，多多少少与他有点共同话题。</p><p>&emsp;由于今年疫情关系，中小型公司都很惨，我们公司当然也不例外，而且由于业务关系，疫情后期简直惨不忍睹。开会说公司的财务状况很紧张，以至于我们的薪水有时都是借贷来发放，但我知道的，不管财务多紧张，至少没有一个月他拖欠了工资。</p><p>&emsp;18.03～20.07，很快，两年时间，有一起加班到凌晨赶着项目上线，有一起在办公室吃泡面发布版本…….缘，妙不可言，一切感谢相遇。</p><p>&emsp;还记得开会，老板对我们说的一句 “像Thorn这种放荡不羁，喜欢在路上的人，以后失了业，可能也就不会去工作了”。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;聚散终有时，感谢相遇&quot;&gt;&lt;a href=&quot;#聚散终有时，感谢相遇&quot; class=&quot;headerlink&quot; title=&quot;聚散终有时，感谢相遇&quot;&gt;&lt;/a&gt;聚散终有时，感谢相遇&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;浪潮来临时，没有一粒尘埃可以在浪花下避免。&lt;/p&gt;
      
    
    </summary>
    
      <category term="Life" scheme="https://thorns.cn/categories/Life/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode.11 盛最多水的容器</title>
    <link href="https://thorns.cn/2020/06/24/leetcode_11.html"/>
    <id>https://thorns.cn/2020/06/24/leetcode_11.html</id>
    <published>2020-06-24T10:12:00.000Z</published>
    <updated>2020-06-24T10:13:36.130Z</updated>
    
    <content type="html"><![CDATA[<h2 id="leetcode-盛最多水的容器"><a href="#leetcode-盛最多水的容器" class="headerlink" title="leetcode 盛最多水的容器"></a>leetcode 盛最多水的容器</h2><blockquote><p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。  </p></blockquote><p>解题思路  </p><p>通过题意知道是求最大面积，宽度为两根柱子的距离x，高度取最短的一根柱子y， x * y = area<br>所以得知当x，y越大时，面积越大，通过双指针遍历，一个指向begin，一个指向end，结束条件是两个指针重逢<br>判断条件是x和y两根柱子谁的高度低，各自代表的指针就向前偏移，所以可以使用双指针的方法来解决此题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>,right = height.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> maxArea = min(height[left],height[right]) * right;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left != right) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (height[left] &lt; height[right])</span><br><span class="line">                left++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right--;</span><br><span class="line">            maxArea = max(maxArea,min(height[left],height[right]) * (right-left));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;leetcode-盛最多水的容器&quot;&gt;&lt;a href=&quot;#leetcode-盛最多水的容器&quot; class=&quot;headerlink&quot; title=&quot;leetcode 盛最多水的容器&quot;&gt;&lt;/a&gt;leetcode 盛最多水的容器&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给
      
    
    </summary>
    
      <category term="leetcode" scheme="https://thorns.cn/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>在路上的故事</title>
    <link href="https://thorns.cn/2020/06/10/story.html"/>
    <id>https://thorns.cn/2020/06/10/story.html</id>
    <published>2020-06-10T12:33:00.000Z</published>
    <updated>2020-06-10T12:37:38.846Z</updated>
    
    <content type="html"><![CDATA[<h2 id="在路上的故事"><a href="#在路上的故事" class="headerlink" title="在路上的故事"></a>在路上的故事</h2><p>&emsp;那个夏天在乔尔玛的时候，下雨，那发出微弱却温暖的烟光把帐篷烫了一个洞，一对从江西出发环华2万公里的夫妇从新藏线赶来独库，在西瓜棚边我跟他们有说有笑，他们分享他们一路上的行程，所见所闻，从家里把自己的SUV打造成在路上的房车 普通人也可以做到，在他们的后备箱有冰箱有厨具，还有容得下彼此的空间真好，我们从南疆聊到北疆、从川藏聊到新藏、从我工作聊到他孩子留学，这种彼此之间，在过往素未谋面只因相同的爱好聚到一起开怀畅聊的感觉真好。  </p><p>到最后，夜晚11点多我记得那一句</p><p>“小兄弟，我把车停在你前面，这样风就吹不到你了”    </p><p><img src="http://image.thorns.cn/qiao1.jpeg" alt="avatar"></p><p>&emsp;火车一直往前开，穿越了湖泊、高原、雪山，在塔里木沙漠公路因为缺水暴晒，第一次在路上骑行有挺不住的想法，路过了一辆越野问我从哪里来，我没理只给他比了一个👍手势，那是自己在骑行路上收到的第一瓶红牛，那瓶红牛让我继续坚持骑行了100公里，一个人在沙漠里哼起了他的歌，“星空和黑夜，我们生来就是孤独～ 你就像屎的倒影”，我想在那个时间那个点，埋头哼唱是自由的，谁也不会听见，风声会携带着沙尘穿过我的低聆飞向沙暴中心去到无人的远方。  </p><p><img src="http://image.thorns.cn/shamo.jpeg" alt="avatar"></p><p>&emsp;时间如果在往前旋转点，接近天黑在霍城县里找不到露营的地方，无奈跑到了一座深巷老旧的院子里，我害羞的跟着陌生人询问“能不能在这里搭个帐篷路个营”，我记得自己都听不懂在讲个什么，害羞、不好意思的情绪支配着我的嘴进行动作，她担心我在院子里睡着不舒服被风吹，拿钥匙给我开了一间没有人住的房间叫我搭在里面，还主动邀请自己去他们家吃饭，被我婉拒了…</p><p><img src="http://image.thorns.cn/luyk.jpeg" alt="avatar"></p><p>&emsp;依稀还记得，春节过年，环岛骑行，科学自由，像个傻逼。那是自己第一次意义上的在路上，那是在元旦跨完年从南京回来就做好的决定，那年距离现在其实并不久，也就两年的时光。</p><p><img src="http://image.thorns.cn/kext.jpeg" alt="avatar"></p><p><img src="http://image.thorns.cn/hdnj.jpeg" alt="avatar"></p><p>&emsp;回想起来，在路上，虽一人往，但需要铭记于心的人太多太多，时常想起仍觉得美好。一直在耳朵旁陪着我的那个南京市民从海南环岛、新疆骑行、绿皮火车、关于郑州、定西兰州……如今他没在路上陪我很久很久了，甚至已经记不起他是那副模样，只知道在路上一直有他在耳边，我就还能继续前行。当然也忘不了在沙漠外围铁运轨路下自己在墙壁写上的那几个字，想起来过于傻逼，也就不想贴了。今年原本计划的尼泊尔EBC之行，因疫情，无奈之下退了票。</p><p>&emsp;这些都没有什么不好，无法在路上就宅家修身养性，无法听到想听的歌，就不用在麻烦试着去找资源听了，无法看的书，那就换一本看吧。但不管怎样，当这些在路上的故事再也无法往返，我想——唯一能做的就是带着感动去铭记那些瞬间，哪怕再也无法有这种体验，也要记得 forever。</p><p><img src="http://image.thorns.cn/ontheroad.jpeg" alt="avatar"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;在路上的故事&quot;&gt;&lt;a href=&quot;#在路上的故事&quot; class=&quot;headerlink&quot; title=&quot;在路上的故事&quot;&gt;&lt;/a&gt;在路上的故事&lt;/h2&gt;&lt;p&gt;&amp;emsp;那个夏天在乔尔玛的时候，下雨，那发出微弱却温暖的烟光把帐篷烫了一个洞，一对从江西出发环华2万公里
      
    
    </summary>
    
      <category term="Life" scheme="https://thorns.cn/categories/Life/"/>
    
    
  </entry>
  
  <entry>
    <title>20.Vaild Parentheses</title>
    <link href="https://thorns.cn/2020/01/09/leetcode_20.html"/>
    <id>https://thorns.cn/2020/01/09/leetcode_20.html</id>
    <published>2020-01-09T03:19:00.000Z</published>
    <updated>2020-01-09T15:20:15.167Z</updated>
    
    <content type="html"><![CDATA[<h2 id="leetcode-20-Vaild-Parentheses"><a href="#leetcode-20-Vaild-Parentheses" class="headerlink" title="leetcode -20.Vaild Parentheses"></a>leetcode -20.Vaild Parentheses</h2><p>&emsp;题目:给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p><p>有效字符串需满足：</p><p>​    1.左括号必须用相同类型的右括号闭合。<br>​    2.左括号必须以正确的顺序闭合。<br>​    3.注意空字符串可被认为是有效字符串。  </p><p>解题思路：可以用stack的先进后出的特性和map来解决此题，使用map存放所有(),[],{},需要注意的是将反向的括号作为键，正向的作为值，遍历字符串，判断字符是否正向，如果是正向的就放入到stack中，如果不是判断栈里面的元素是否等于当前遍历的字符，不等于说明该字符串就是无效的。</p><p>&emsp;代码如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">   <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">char</span>&gt; p = &#123;&#123;<span class="string">')'</span>,<span class="string">'('</span>&#125;,&#123;<span class="string">']'</span>,<span class="string">'['</span>&#125;,&#123;<span class="string">'&#125;'</span>,<span class="string">'&#123;'</span>&#125;&#125;;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; st;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> ch : s)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//判断当前字符是否是正向的，如果是，放入到stack中</span></span><br><span class="line">      <span class="keyword">if</span> (!p.count(ch))</span><br><span class="line">      &#123;</span><br><span class="line">        st.puch(ch);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> (st.empty() || p[ch] != st.top())</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">//说明是一对有效的符号，弹出接着遍历下一对</span></span><br><span class="line">          st.pop();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> st.empty();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可能刚开始看着的时候不太理解，如果换作java的stack就好理解，因为java中的stack pop函数会返回对象，而C++的不会，所以这里借助了map实现，Java可以判断遍历的字符是正向的括号，如果是就放入对应的反向括号到Stack中，如果遍历遇到反向的括号就弹出Stack最后一位元素，跟当前字符比较，不相等或者Stack为空，就可以得出该字符串是无效的括号</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;leetcode-20-Vaild-Parentheses&quot;&gt;&lt;a href=&quot;#leetcode-20-Vaild-Parentheses&quot; class=&quot;headerlink&quot; title=&quot;leetcode -20.Vaild Parentheses&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="leetcode" scheme="https://thorns.cn/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Imagine</title>
    <link href="https://thorns.cn/2020/01/08/imagine.html"/>
    <id>https://thorns.cn/2020/01/08/imagine.html</id>
    <published>2020-01-08T10:23:00.000Z</published>
    <updated>2020-01-08T10:26:38.100Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Imagine"><a href="#Imagine" class="headerlink" title="Imagine"></a>Imagine</h2><blockquote><p>给那些在战争中的小孩儿  </p></blockquote><p>《Imagine》  ——John Lennon</p><p>Imagine theres no heaven</p><p>Its easy if you try</p><p>No hell below us</p><p>Above us only sky</p><p>Imagine all the people</p><p>Living for today</p><p>Imagine theres no countries </p><p>It isn’t hard to do</p><p>Nothing to kill or die for</p><p>And no religion too</p><p>Imagine all the people</p><p>Living life in peace</p><p>You may say I’m a dreamer</p><p>But I’m not the only one</p><p>I hope someday you’ll join us</p><p>And the world will be as one</p><p>Imagine no possessions</p><p>I wonder if you can</p><p>No need for greed or hunger</p><p>A brotherhood of man</p><p>Imagine all the people</p><p>Sharing all the world…</p><p>You may say I’m a dreamer</p><p>But I’m not the only one</p><p>I hope someday you’ll join us</p><p>And the world will be as one</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Imagine&quot;&gt;&lt;a href=&quot;#Imagine&quot; class=&quot;headerlink&quot; title=&quot;Imagine&quot;&gt;&lt;/a&gt;Imagine&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给那些在战争中的小孩儿  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;《I
      
    
    </summary>
    
      <category term="Life" scheme="https://thorns.cn/categories/Life/"/>
    
    
  </entry>
  
  <entry>
    <title>1.Two sum</title>
    <link href="https://thorns.cn/2019/12/22/leetcode_1.html"/>
    <id>https://thorns.cn/2019/12/22/leetcode_1.html</id>
    <published>2019-12-22T03:39:47.000Z</published>
    <updated>2019-12-22T15:39:35.828Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原题描述"><a href="#原题描述" class="headerlink" title="原题描述:"></a>原题描述:</h2><blockquote><p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.</p></blockquote><p>给定一个数组，返回两个数在数组中的索引，使它们相加等于给定的目标值。  </p><p>解题思路：使用map的key-value结构存放遍历过数组元素的值和下标，在map中直接查找,有插入到返回的vector中，没有插入到map。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; twoSum(vector&lt;int&gt; &amp;nums,int target)</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; result;</span><br><span class="line">    map&lt;int,int&gt; hashmap;</span><br><span class="line">    map&lt;int,int&gt;::iterator iter;</span><br><span class="line">    for (int i = 0; i &lt; nums.size();++i)</span><br><span class="line">    &#123;</span><br><span class="line">        iter = hashmap.find(target-nums[i]);</span><br><span class="line">        if (iter != hashmap.end())</span><br><span class="line">        &#123;</span><br><span class="line">            result.push_back(i);</span><br><span class="line">            result.push_back(iter-&gt;second);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;   </span><br><span class="line">            hashmap.insert(pair&lt;int,int&gt;(nums[i],i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;原题描述&quot;&gt;&lt;a href=&quot;#原题描述&quot; class=&quot;headerlink&quot; title=&quot;原题描述:&quot;&gt;&lt;/a&gt;原题描述:&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Given an array of integers, return indices of t
      
    
    </summary>
    
      <category term="leetcode" scheme="https://thorns.cn/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>记窗外耳声</title>
    <link href="https://thorns.cn/2019/12/10/1210.html"/>
    <id>https://thorns.cn/2019/12/10/1210.html</id>
    <published>2019-12-10T01:20:00.000Z</published>
    <updated>2020-06-10T12:37:53.090Z</updated>
    
    <content type="html"><![CDATA[<p>隐约在耳边听到一句”港岛妹妹”<br>对着窗外吼了一句<br>“天空之城在哭泣”<br>踏着拖鞋叼上一根烟<br>去寻找那近乎于耳的声音源头<br>一个清吧，一个酒吧，地铁街头<br>无果，终返回<br>检查口袋还好带上了门禁<br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;隐约在耳边听到一句”港岛妹妹”&lt;br&gt;对着窗外吼了一句&lt;br&gt;“天空之城在哭泣”&lt;br&gt;踏着拖鞋叼上一根烟&lt;br&gt;去寻找那近乎于耳的声音源头&lt;br&gt;一个清吧，一个酒吧，地铁街头&lt;br&gt;无果，终返回&lt;br&gt;检查口袋还好带上了门禁&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Life" scheme="https://thorns.cn/categories/Life/"/>
    
    
  </entry>
  
  <entry>
    <title>需以春风待人</title>
    <link href="https://thorns.cn/2019/11/16/love.html"/>
    <id>https://thorns.cn/2019/11/16/love.html</id>
    <published>2019-11-16T10:00:00.000Z</published>
    <updated>2019-11-18T16:16:53.256Z</updated>
    
    <content type="html"><![CDATA[<p>春风再美也比不上你的笑。<br>        ————2019-11-16<br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;春风再美也比不上你的笑。&lt;br&gt;        ————2019-11-16&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Life" scheme="https://thorns.cn/categories/Life/"/>
    
    
  </entry>
  
  <entry>
    <title>亲爱的李志先生，生日快乐</title>
    <link href="https://thorns.cn/2019/11/13/happybirthday.html"/>
    <id>https://thorns.cn/2019/11/13/happybirthday.html</id>
    <published>2019-11-13T02:31:00.000Z</published>
    <updated>2019-11-13T15:03:49.788Z</updated>
    
    <content type="html"><![CDATA[<h2 id="亲爱的李志先生，生日快乐"><a href="#亲爱的李志先生，生日快乐" class="headerlink" title="亲爱的李志先生，生日快乐"></a>亲爱的李志先生，生日快乐</h2><p>&emsp;他们到底在害怕什么？克拉玛依新鲜的空气？金陵热河街头来往的人们？山阴路下隐世的书店？还是来自远处未知名渴望的呼唤……我不知道。  </p><p>&emsp;在他被“行为不端”后，带着这个问题，我愤怒不解的读完了《摇滚乐可能改变世界吗》，试图去了解整个“摇滚史”，在书里想找到答案。无果。又在低沉时翻起了对他影响很大的作家——王小波同志的《沉默的大多数》，到现在我继续读着老大哥的《1984》，这本1949年描绘1984年的读物，在今天2019年看毫不过时，甚至还有那么一丝丝写实。也试图在音乐中寻找答案， 当我听到Pink Floyd的《Shine On You Crazy Diamond》，我找到了那首被禁忌的《被禁忌的游戏》熟悉的旋律，和久违的《墙上的向日葵》的前奏，那一刻开心的像个含糖的孩子，可我还是不知道他们到底在害怕什么。  </p><p>&emsp;当浪潮来临时，我看见有做IT行业的”码农”，自告奋勇的做了一个能听到他歌声的网站，有从事律师专业的人写了好几份”上书”以求”行为不端”背后的解释，有收藏者把他的歌拿出来分享的群众……像孤岛海洋上的一叶沉船聚在一起，彼此相拥，不能自已。至于断浆能不能划，已经释然了，或许我们都是那个  </p><blockquote><p>四体不勤，五谷不分<br>终于沦为沉默的帮凶</p></blockquote><p>的大多数。<br><img src="http://image.thorns.cn/lizhi.png" alt="avatar"><br><img src="http://image.thorns.cn/livi2.jpeg" alt="avatar"><br><img src="http://image.thorns.cn/livi3.jpeg" alt="avatar"><br>&emsp;好吧，不管怎样，亲爱的李志先生，祝您四十一岁生日快乐。<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;——2019-11.13-10:29</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;亲爱的李志先生，生日快乐&quot;&gt;&lt;a href=&quot;#亲爱的李志先生，生日快乐&quot; class=&quot;headerlink&quot; title=&quot;亲爱的李志先生，生日快乐&quot;&gt;&lt;/a&gt;亲爱的李志先生，生日快乐&lt;/h2&gt;&lt;p&gt;&amp;emsp;他们到底在害怕什么？克拉玛依新鲜的空气？金陵热河
      
    
    </summary>
    
      <category term="李志" scheme="https://thorns.cn/categories/%E6%9D%8E%E5%BF%97/"/>
    
    
  </entry>
  
  <entry>
    <title>IP协议详解</title>
    <link href="https://thorns.cn/2019/10/10/ip%E5%8D%8F%E8%AE%AE.html"/>
    <id>https://thorns.cn/2019/10/10/ip协议.html</id>
    <published>2019-10-10T15:35:00.000Z</published>
    <updated>2019-10-24T07:41:43.671Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>众所周知,IP是TCP/IP协议族中最为核心的协议，深入了解IP协议对我们实际开发、网络编程据有很大的帮助，遇到问题时，能知其然知其所以然，调试问题时能快速定位问题源并加以解决。</p></blockquote><p>&emsp;每次写socket编程时，遇到网络错误或者底层错误时，都是知其然不知其所以然，对于我这种喜欢捣鼓底层，喜欢明白事物本身实质的，显然是不行的，遂拿起了《TCP/IP详解》这三件套，书的作者W. Richard Stevens是位很牛逼的大佬，国际知名的Unix和网络专家前贝尔实验室Unix系统V版本4的开发人员之一，除了TCP/IP三卷(协议、实现、TCP事务协议)，还著有有着Unix圣经之称的《Unix网络编程》(两卷本)，有兴趣的小伙伴都可以去看看。</p><blockquote><p>此篇文章是针对书中第三章作的一份小结</p></blockquote><h3 id="IP-网际协议"><a href="#IP-网际协议" class="headerlink" title="IP:网际协议"></a>IP:网际协议</h3><p>&emsp;IP是TCP/IP协议族的核心，它位于TCP/IP四层模型的网络层，负责Internet网络之间的通信，并定义了数据传输时的基本单元和格式，还定义了数据包的递交方法和路由选择。<br>&emsp; 1.IP是面向无连接的传输服务，不维护IP数据报发送后的状态信息，数据报在传输过程可能丢失，统一交给上层自己去维护<br>&emsp; 2.IP是不可靠的数据投递服务，IP协议本身没有办法确认发送的报文是否被正确接受，数据报可能在线路延迟、路由错误、分片、重组等过程中损坏，IP不检测这些错误，也没有可靠的机制来通知发送方或接收方  </p><h4 id="1-IP地址"><a href="#1-IP地址" class="headerlink" title="1. IP地址"></a>1. IP地址</h4><p>&emsp;IP地址是一个32位的二进制地址，由网络号和主机号组成。为了方便记忆，将它们分为4组，每组8位由小数点分开，这种表示方法叫做点分十进制，例如192.168.1.1。</p><h5 id="1-1-IP地址类别"><a href="#1-1-IP地址类别" class="headerlink" title="1.1 IP地址类别"></a>1.1 IP地址类别</h5><p>&emsp;IP地址分为五类，A类，B类，C类，D类，E类  </p><table><thead><tr><th>类别</th><th>网段</th><th>区分</th><th>地址范围</th><th>网络数</th><th>主机数</th></tr></thead><tbody><tr><td>A类</td><td>0-127</td><td>首位为0</td><td>1.0.0.1～127.255.255.254</td><td>126（2^7-2）</td><td>2^24-2</td></tr><tr><td>B类</td><td>128-191</td><td>首位为10</td><td>128.0.0.1～191.255.255.254</td><td>16383(2^14-1)</td><td>2^16-2</td></tr><tr><td>C类</td><td>192-223</td><td>首位为110</td><td>192.0.0.1～223.255.255.254</td><td>2^24-1</td><td>2^8-2</td></tr><tr><td>D类</td><td>224-239</td><td>首位为1110</td><td>224.0.0.1~239.255.255.254</td><td>不区分网络地址和主机地址</td></tr><tr><td>E类</td><td>240～255</td><td>首位为11110</td><td>保留地址</td></tr></tbody></table><ul><li>A类：由一个字节的网络号和三个字节的主机号组成，默认子网掩码(255.0.0.0)，最高位必须为0，网络数减2是因为  <ul><li>1.网络号全为0的IP地址为保留地址，表示本网络</li><li>2.A类IP地址中网络号为127的地址保留用于环回测试本机的进程间通信（127.0.0.0～127.255.255.255都为保留地址）  </li></ul></li><li>B类：由两个字节的网络号和两个字节的主机号组成，默认子网掩码(255.255.0.0)，网络数减1也是因为网络全为0表示本网络，不能被指派，前面首位为0。  </li><li>C类：由三个字节的网络号和两个字节的主机号组成，默认子网掩码(255.255.255.0),减1同理</li><li>D类：保留地址，不分网络和主机地址，主要用于多播地址</li><li>E类：保留地址，为将来使用保留  </li></ul><h5 id="1-2-公有地址和私有地址"><a href="#1-2-公有地址和私有地址" class="headerlink" title="1.2 公有地址和私有地址"></a>1.2 公有地址和私有地址</h5><p>&emsp;我们能经常听到公有地址和私有地址，包括去腾讯云、阿里云购买服务器，都会分配一个公有地址和一个私有地址  </p><p>&emsp;<strong>公有地址</strong>：公有地址（Public address）由Inter NIC（Internet Network Information Center 因特网信息中心）负责。这些IP地址分配给注册并向Inter NIC提出申请的组织机构。通过它直接访问因特网。简单一句话讲就是外部主机能访问你这个地址的就是公有地址<br>&emsp;<strong>私有地址</strong>：私有地址属于非注册地址，专门为组织机构内部使用，只能处于在同一网段的主机才能访问，属于局域网范畴</p><h5 id="1-3-私有地址范围"><a href="#1-3-私有地址范围" class="headerlink" title="1.3 私有地址范围"></a>1.3 私有地址范围</h5><p>&emsp;以下为A、B、C三类私有地址范围，只用于在局域网上<br>| 类别 | 范围 |<br>| —- | —- |<br>|A类|10.0.0.0～10.255.255.255|<br>|B类|172.16.0.0～172.31.255.255|<br>|C类|192.168.0.0～192.168.255.255|</p><h4 id="2-IP首部"><a href="#2-IP首部" class="headerlink" title="2.IP首部"></a>2.IP首部</h4><p>&emsp;当应用程序传送数据时，数据被送入协议栈中，经过TCP/IP四层模型时，其中每一层对收到的数据都要增加一些首部信息(有时候还会增加尾部信息)，IP传给数据链路层的数据单元称作IP数据报(IP datagram).<br><img src="http://image.thorns.cn/header.jpg" alt=""></p><p>从左到右，依次是最高位到最低位。<br>大端字节序(big endian):高位字节在前，低位字节在后。也就是0～7bit在前，其次8～15bit…<br>小端字节序(little endian):低位字节在前，高位字节在后。24～31bit在前，依次</p><h5 id="2-1-字段含义"><a href="#2-1-字段含义" class="headerlink" title="2.1 字段含义"></a>2.1 字段含义</h5><ul><li>版本：占4位，表示IP协议的版本，目前是4，因此也叫做IPv4。IPv6目前还没普及。</li><li>首部长度：4位，指IP首部大小，单位字节。因为该字段值最大为15，所以IP首部最大长度为60个字节，且IP首部长度必须为4的整数倍，不是整数倍使用最后的选项字段进行填充</li><li>服务类型(TOS):8位，用来获取更好的服务，但实际上一直没被使用过  <ul><li>前3bit表示优先权(现已被忽略)</li><li>4bit的TOS字段包括最小时延、最大吞吐量、最高可靠性、最小费用</li><li>1bit未用位必须置0  </li></ul></li><li>总长度：16位，指整个IP数据报的长度，以字节为单位，利用IP首部长度字段和该字段就可以知道IP数据报中数据内容的起始位置和长度，由于该字段长16bit，所以IP数据报最长可达65535字节(最大传送单元MTU)，但要注意当一个IP数据报经过链路层被封装帧时，一定不能超过数据链路层的MTU值</li><li>标识：16位，唯一地标示主机发送的每一份数据报，通常每发送一份报文它的值就会加1，主要用于分片重组时，通过该字段重组为原来的数据报</li><li>标志：占3位  <ul><li>标志字段中的最低位记为MF(More Fragment)。MF=1即表示后面“还有分片”的数据报。MF=0表示这已是若干数据报片中的最后一个</li><li>标志字段中间的一位记为DF(Don’t Fragment)，意思是“不能分片”。只有当DF=0时才允许分片。</li></ul></li><li>片偏移：13位，在分片后，某片在原分组中的相对位置。也就是说，相对用户数据字段的起点，该片从何处开始。片偏移以8个字节为偏移单位。这就是说，每个分片的长度一定是8字节（64位）的整数倍。  </li><li>TTL:8位，单位秒或跳站数目，表示数据报可以经过的最多路由器数，初始值由源主机设置，一旦经过一个处理它的路由器值就减1，当值为0时，数据报就被丢弃，并发送ICMP报文通知源主机</li><li>协议：8位，指数据报传输数据是用的哪种协议，在linux系统的/etc/protocols文件中定义了所有上层协议对应的值，ICMP为1，TCP为6，UDP是17</li><li>首部校验和：16位，指根据IP首部计算检验和码，用来检查数据报在传输过程中是否出现错误</li></ul><h4 id="3-IP路由选择"><a href="#3-IP路由选择" class="headerlink" title="3.IP路由选择"></a>3.IP路由选择</h4><p>&emsp;IP路由选择是逐跳地(hop-by-hop)进行的,如果目的主机与源主机不是在同一个网络，主机会把数据报发往路由器上，由路由器来转发数据报，直至目的主机。<br>&emsp;路由表中的每一项都包含下面这些信息:  </p><ul><li>目的IP地址，可以是一个完整的主机地址，也可以是一个网络地址。由标志字段指定</li><li>下一跳路由器的IP地址，或者有直接相连的网络IP地址，下一跳路由器不是最终目的，但是通过它可以将数据报转发到最终目的</li><li>标志：指明目的IP地址是网络地址还是主机地址，另一个标志指明下一跳路由器是否为真正的路由器，还是一个直连的接口 </li><li>为数据报的传输指定一个网络接口  </li></ul><p>从中我们可以看出，IP并不知道任何目的地完整路径，所以IP路由选择主要完成以下功能：</p><ol><li>搜索路由表，寻找能与目的IP地址完全匹配的表目。找到，则把报文发送给该表目指定的下一跳路由器或者直连的网络接口(取决于标志字段的值)</li><li>搜索路由表，寻找能与目的网络号相匹配的表目。找到，则把报文发送给表目指定的下一跳路由器或直连的网络接口。目的网络上所有主机都可以通过这个表目来处置。这种搜索方法必须考虑子网掩码</li><li>搜索路由表，寻找标为默认的表目。找到，则把报文发送该表目指定的下一跳路由器。  </li></ol><p>假如上面这些步骤都没有成功，那么这个数据报就不能被传送，且就会返回主机不可达或者网络不可达</p><h4 id="4-子网掩码"><a href="#4-子网掩码" class="headerlink" title="4.子网掩码"></a>4.子网掩码</h4><p>&emsp;子网掩码是32位的二进制数，表示地址哪一部分为网络地址，哪一部分为主机地址。对应网络地址的位都是1，主机地址都为0。<br>&emsp;例如，有一个IP地址是：192.168.0.5，默认子网掩码是：255.255.255.0，那么该IP的网络地址是192.168.0.0<br>&emsp;计算方法：<br><strong>1.</strong> 将IP地址与子网掩码转换成二进制<br><strong>2.</strong> 将转换成二进制的IP地址和子网掩码做与运算，得到的结果就是网络地址<br><strong>3.</strong> 将二进制形式的子网掩码取反<br><strong>4.</strong> 将取反后的子网掩码和IP地址做与运算，得到的结果就是主机地址</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;众所周知,IP是TCP/IP协议族中最为核心的协议，深入了解IP协议对我们实际开发、网络编程据有很大的帮助，遇到问题时，能知其然知其所以然，调试问题时能快速定位问题源并加以解决。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;emsp;每次写sock
      
    
    </summary>
    
      <category term="TCP/IP详解" scheme="https://thorns.cn/categories/TCP-IP%E8%AF%A6%E8%A7%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>记一次内存泄漏</title>
    <link href="https://thorns.cn/2019/10/06/memory_leak.html"/>
    <id>https://thorns.cn/2019/10/06/memory_leak.html</id>
    <published>2019-10-06T10:42:00.000Z</published>
    <updated>2019-10-06T10:46:32.451Z</updated>
    
    <content type="html"><![CDATA[<h1 id="记一次内存泄漏"><a href="#记一次内存泄漏" class="headerlink" title="记一次内存泄漏"></a>记一次内存泄漏</h1><p>&emsp;最近在工作上遇到软件崩溃的问题，基于mfc的一个pc软件。苦苦调试了几天，输出日志，查看堆栈都没什么结果，只知道是内存泄漏引起的。<br>&emsp;昨天国庆假期，迫于无聊就去公司再次查看这个问题，使用windbg分析得知是字体资源太多导致，认真review代码了，发现问题原来是出在CreateFontIndirect这个函数上，软件中使用到ListBox需要针对不同类型的ListBox使用不同的字体，在类中声明了一个CFont的字体对象，当需要使用不同的字体时，自己直接又一次调用了CreateFontIndirect，并没有调用DeleteObject，所以导致了内存泄漏。</p><p>&emsp;因为自己并不是很熟悉Gdi+,所以才有这个问题发生，原来vc中的任何资源，字体、画笔、画刷、DC等都不能在同一个对象上二次创建，如果需要二次创建，必须将前次的销毁才行。特此记录一下。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;记一次内存泄漏&quot;&gt;&lt;a href=&quot;#记一次内存泄漏&quot; class=&quot;headerlink&quot; title=&quot;记一次内存泄漏&quot;&gt;&lt;/a&gt;记一次内存泄漏&lt;/h1&gt;&lt;p&gt;&amp;emsp;最近在工作上遇到软件崩溃的问题，基于mfc的一个pc软件。苦苦调试了几天，输出日志，查看
      
    
    </summary>
    
      <category term="C++" scheme="https://thorns.cn/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>生活没有答案，但总有下一站</title>
    <link href="https://thorns.cn/2019/08/29/life_MD.html"/>
    <id>https://thorns.cn/2019/08/29/life_MD.html</id>
    <published>2019-08-29T00:05:00.000Z</published>
    <updated>2019-08-29T05:35:16.981Z</updated>
    
    <content type="html"><![CDATA[<h1 id="生活没有答案，但总有下一站"><a href="#生活没有答案，但总有下一站" class="headerlink" title="生活没有答案，但总有下一站"></a>生活没有答案，但总有下一站</h1><blockquote><p>生活没有答案，但总有下一个站</p></blockquote><h2 id="黑夜中寻找那丝微光"><a href="#黑夜中寻找那丝微光" class="headerlink" title="黑夜中寻找那丝微光"></a>黑夜中寻找那丝微光</h2><p>&emsp;到沙漠公路的时候这次环疆就宣告了结束，一个人骑到了塔里木胡杨林景区就没有再往前行驶，记得要开始骑沙漠的时候我给我朋友说“不想骑了”，朋友立马着急的打电话过来问我“是骑不动了？还是真的就不想骑了，不骑完你回来一周就会后悔的！”，“不想骑了”…   </p><p>我也不知道为什么不想骑了，或许是沙漠里面天太热？景色太单一审美疲劳了？还是一个人太无聊枯燥了？不是的，我还有更重要的事情要去做，我还没去兰州在大西北灰蒙蒙的清晨吃上一碗正宗的兰州拉面听上一曲《金城兰州》，也还没去定西背靠贫瘠的山陵街道上，端着一碗地道的定西洋芋小吃听着那么一句</p><blockquote><p>“这么多年，你一个人一直在走，<br>方向和天气的节奏会让你哀愁”</p></blockquote><p>也要路过那座有情有义有米可炊的城市——郑州，去写下一份关于我自己的《关于郑州的记忆》。我想没有比这个更重要的事了！这些羁绊的东西在黑夜里折磨着我却又给我指好行驶的方向，让我去寻找那丝微光，真的没有骗你。</p><h2 id="生活没有答案"><a href="#生活没有答案" class="headerlink" title="生活没有答案"></a>生活没有答案</h2><p>&emsp;骑完了，历时十六天，一千四百多公里，没多远。那一刻我想把一切都丢掉，丢掉…车子丢在沙漠公路的终点，把衣服清洁好捐出去，空身回家就带一个人。可我没有那勇气，就像出来那样没有勇气，我以为一路下来会有个答案，会有个结果。躺在宾馆的白床铺上，“我太俗了，怎么会以为有个answerer给我一个answer”，没有的，有的只是路上的花，马牛羊在山坡上吃草和在公路上奔跑。他说</p><blockquote><p>“生活是苦难的，我又划着我的断桨出发了”</p></blockquote><p>前半句我其实是不赞同的，相反我更喜欢那句</p><blockquote><p>“生活在于它的不确定性”  </p></blockquote><p>&emsp;你不会知道明天的你是依然过着这重复着重复着重复的日子，还是在遥远看得见光的下面奔跑，是不确定的，也不会有先知在你睡不着的夜晚来告诉你一个答案。生活没有答案。</p><h2 id="下一个车站"><a href="#下一个车站" class="headerlink" title="下一个车站"></a>下一个车站</h2><p>&emsp;“各位旅客你们好，下一站兰州车站，请各位要下车的旅客，提前收拾好你们的行李，准备下车” ，背上了包下了火车，出站口的那一刻阳光洒在我脸上，我忍不住给它比了摇滚的手势，像个孩子似的在广场大声欢呼（当然我也不会在乎旁人的看法）做上131到中山桥的公交车，还是喜欢坐在下站门口的前排靠窗位置，打开手机准备写一点东西来记录回忆，突然映入我眼前的一个蓝底牌子白色三个大字“定西路”，我想立即下车最终还是忍住了，因为我知道这里是兰州不是定西。随即我又想起我咋忘买一包兰州了，怎么会把这个事情给忘记了呢？我不知道，但总想着等公交车到了下一个车站，我就去买一包兰州，等动车开往定西的时候，我就拿起手机“咔嚓”一下拍个照，等下一个车站，在下一个车站，总会有我们期待已久，懊悔过许久，能给我们一丝慰藉。也许下一站需要很久，半小时，五小时，甚至四十八小时，甚至更久…乃至活到出头。<br>&emsp;但我真的在下一站见到七八十岁的老奶奶老大爷在欢声歌唱，没有骗你。<br><img src="http://image.thorns.cn/12312.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;生活没有答案，但总有下一站&quot;&gt;&lt;a href=&quot;#生活没有答案，但总有下一站&quot; class=&quot;headerlink&quot; title=&quot;生活没有答案，但总有下一站&quot;&gt;&lt;/a&gt;生活没有答案，但总有下一站&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;生活没有答案，但总有下一个
      
    
    </summary>
    
      <category term="“旅途”" scheme="https://thorns.cn/categories/%E2%80%9C%E6%97%85%E9%80%94%E2%80%9D/"/>
    
    
  </entry>
  
  <entry>
    <title>等他回来</title>
    <link href="https://thorns.cn/2019/07/15/waitforhimtocomeback.html"/>
    <id>https://thorns.cn/2019/07/15/waitforhimtocomeback.html</id>
    <published>2019-07-15T04:30:30.000Z</published>
    <updated>2019-07-15T02:59:33.455Z</updated>
    
    <content type="html"><![CDATA[<h1 id="等他回来"><a href="#等他回来" class="headerlink" title="等他回来"></a>等他回来</h1><blockquote><p>我想等到他回来的那一天,那一天无论身在何处我都会奔着去看他的演出。</p></blockquote><a id="more"></a><p>&emsp;看到身边的朋友都在大喊“痛仰牛逼”，“裤子还是新的好”，“喜欢刺猬的鼓手”,心里面也一阵高兴，我也很喜欢这些，喜欢痛苦的信仰,喜欢没有理想的人不伤心开啤酒的那一下，喜欢刺猬的女鼓手摇滚范儿<br>&emsp;可心底总有一种莫名的情愫笼罩着我——那个男人还是没回来,哎…！让我打不起精神。看到朋友圈有人在分享这首歌,那首歌，我也想分享一首来着，一打开网易云搜索”李志”，查无此人。不知不觉间打开Chrome,想搜索一些东西,又很自然的输入了那个名字,又看了一遍维基百科的介绍,我也不知道从多久我开始这样,心里面难免有点失落和茫然…</p><blockquote><p>真想问一句“妈妈,这种失落会持久吗？”   </p></blockquote><p>所以呀,无论多久,多久都等,等他回来的第一场演出,我们一起相约2000.<br><img src="http://image.thorns.cn/1.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;等他回来&quot;&gt;&lt;a href=&quot;#等他回来&quot; class=&quot;headerlink&quot; title=&quot;等他回来&quot;&gt;&lt;/a&gt;等他回来&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;我想等到他回来的那一天,那一天无论身在何处我都会奔着去看他的演出。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="李志" scheme="https://thorns.cn/categories/%E6%9D%8E%E5%BF%97/"/>
    
    
  </entry>
  
  <entry>
    <title>ARTS 第三周</title>
    <link href="https://thorns.cn/2019/04/06/ARTS_3.html"/>
    <id>https://thorns.cn/2019/04/06/ARTS_3.html</id>
    <published>2019-04-06T09:58:30.000Z</published>
    <updated>2019-04-06T15:45:56.394Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>What’s ARTS？<br>A:Algorithm 每周至少做一个leetcode的算法题<br>R:Review 阅读并点评至少一遍英文技术文章<br>T:Tip 学习至少一个技术技巧<br>S:Share 分享一篇有观点和思考的技术文章  </p></blockquote><h2 id="1-Algorithm"><a href="#1-Algorithm" class="headerlink" title="1. Algorithm"></a>1. Algorithm</h2><blockquote><p>Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.<br>给定一个字符串s，在s中找出最长回文子串。你可以假设s的最大长度为s。</p></blockquote><p>&emsp;这道题难度为Medium，有很多种解法,自己刚开始想到的是使用暴力法去暴力破解，不过这种方法的时间复杂度太高，先枚举所有子串，对每个子串进行判断是否为回文，此种方法的时间复杂度为O(n^3),在网上看到有人用动态规划的方法，遂学习了下动态规划，关于动态规划——想单独写一篇文章记录下，就不在这里介绍了。代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">string longestPalindrome(string s)</span><br><span class="line">&#123;</span><br><span class="line">    if (!s.size())</span><br><span class="line">        return &quot;&quot;;</span><br><span class="line">    int len = s.size();</span><br><span class="line">    int left = 0,right = 0;</span><br><span class="line">    bool dp[len][len];</span><br><span class="line">    dp[0][0] = true;</span><br><span class="line">    for (int i = 1;i&lt;len;++i) &#123;</span><br><span class="line">        dp[i][i] = true;</span><br><span class="line">        dp[i][i-1] = true;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 2;i &lt;= len;++i) &#123;</span><br><span class="line">        for (int j = 0;j &lt;= len-i;++j) &#123;</span><br><span class="line">            if (s[j]==s[len-i-1] &amp;&amp; dp[j+1][j+i-2]) &#123;</span><br><span class="line">                dp[j][i+j-1] = true;</span><br><span class="line">                if (right-left+1 &lt; i) &#123;</span><br><span class="line">                    left = j;</span><br><span class="line">                    right = j+i-1</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return s.substr(left,right-left+1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-Review"><a href="#2-Review" class="headerlink" title="2. Review"></a>2. Review</h2><p>&emsp;先上链接<a href="https://www.codechef.com/wiki/tutorial-dynamic-programming" target="_blank" rel="noopener">Tutorial For Dynamic programming</a><br>&emsp;该文章讲解了Dynamic programming(动态规划)，分别举例说明了DP的两种形式</p><blockquote><p>&emsp;There are two ways of doing this.<br>&emsp;1.) Top-Down : Start solving the given problem by breaking it down. If you see that the problem has been solved already, then just return the saved answer. If it has not been solved, solve it and save the answer. This is usually easy to think of and very intuitive. This is referred to as Memoization.<br>&emsp;2.) Bottom-Up : Analyze the problem and see the order in which the sub-problems are solved and start solving from the trivial subproblem, up towards the given problem. In this process, it is guaranteed that the subproblems are solved before solving the problem. This is referred to as Dynamic Programming. </p></blockquote><h3 id="2-1-Memoization"><a href="#2-1-Memoization" class="headerlink" title="2.1 Memoization"></a>2.1 Memoization</h3><p>&emsp;第一种自顶向下的方法，通过分解来解决给定的问题。如果你发现问题已经解决，就只需要返回已保存的答案，如果尚未解决，请解决并保存答案。这种方法被称为Memoization(备忘录法)。  </p><blockquote><p>&emsp;Recursion uses the top-down approach to solve the problem i.e. It begin with core(main) problem then breaks it into subproblems and solve these subproblems similarily. In this approach same subproblem can occur multiple times and consume more CPU cycle ,hence increase the time complexity. Whereas in Dynamic programming same subproblem will not be solved multiple times but the prior result will be used to optimise the solution. eg. In fibonacci series   </p></blockquote><p>&emsp;自顶向上的方法通常使用递归求解，即它从核心(主要)问题开始，然后将其分解为子问题并解决这些类似的子问题。在这种方法中，相同的子问题可能会多次出现并消耗更多的CPU周期，因此这种解决方法增加时间复杂度</p><h3 id="2-2-Dynamic-Programming"><a href="#2-2-Dynamic-Programming" class="headerlink" title="2.2 Dynamic Programming"></a>2.2 Dynamic Programming</h3><p>&emsp;第二种自底向上的方法，分析问题并查看子问题被解决的顺序，并从子问题开始解决问题，在此过程中，保证在解决问题之前解决子问题，这就是所谓的动态规划。<br>&emsp;关于动态规划会在另一篇博客中详细的介绍、记录一下。  </p><h3 id="2-3-Remark"><a href="#2-3-Remark" class="headerlink" title="2.3 Remark"></a>2.3 Remark</h3><p>&emsp;这篇文章详细的介绍了动态规划的概念，并通过三个问题一一讲解了Memoization和DP这两种解决方法的区别，总的来说是一篇非常不错很适合像我这种之前都不知道DP的人，一看就能懂就会的文章。值得mark</p><h2 id="3-Tips"><a href="#3-Tips" class="headerlink" title="3. Tips"></a>3. Tips</h2><p>最近有使用到docker，在这里简单说下docker一些基础的操作命令  </p><ol><li>docker pull 从镜像仓库拉取指定镜像</li><li>docker images 查看本地所有镜像</li><li>docker rmi 删除本地一个或多个镜像</li><li>docker ps 查看正在运行的容器</li><li>docker ps -a 查看所有容器</li><li>docker run 运行容器,通常使用-it以交互模式运行容器</li><li>docker top 查看容器中运行的进程信息</li><li>docker start/stop/restart 对容器的操作</li><li>docker rm 删除一个容器或多个容器</li></ol><h2 id="4-Share"><a href="#4-Share" class="headerlink" title="4. Share"></a>4. Share</h2><p>分享的还是跟动态规划有关，这个使用漫画的形式，非常详细的介绍了动态规划，几乎纯小白一看就能懂的文章  <a href="https://zhuanlan.zhihu.com/p/31628866" target="_blank" rel="noopener">文章链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;What’s ARTS？&lt;br&gt;A:Algorithm 每周至少做一个leetcode的算法题&lt;br&gt;R:Review 阅读并点评至少一遍英文技术文章&lt;br&gt;T:Tip 学习至少一个技术技巧&lt;br&gt;S:Share 分享一篇有观点和思考的技术文章  
      
    
    </summary>
    
      <category term="ARTS" scheme="https://thorns.cn/categories/ARTS/"/>
    
    
  </entry>
  
  <entry>
    <title>ARTS 第二周  欢迎交流讨论</title>
    <link href="https://thorns.cn/2019/03/31/arts_2.html"/>
    <id>https://thorns.cn/2019/03/31/arts_2.html</id>
    <published>2019-03-31T11:33:47.000Z</published>
    <updated>2019-03-31T13:48:16.597Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>What’s ARTS？<br>A:Algorithm 每周至少做一个leetcode的算法题<br>R:Review 阅读并点评至少一遍英文技术文章<br>T:Tip 学习至少一个技术技巧<br>S:Share 分享一篇有观点和思考的技术文章  </p></blockquote><h2 id="1-Algorithm"><a href="#1-Algorithm" class="headerlink" title="1.Algorithm"></a>1.Algorithm</h2><p>Longest Substring Without Repeating Characters，找出最长且不重复的子串<br>Example 1:   </p><blockquote><p>Input:&emsp;”abcabcbb”<br>Output:&emsp;”3”<br>Explanation: The answer is “abc”, with the length of 3</p></blockquote><p>Example 2:  </p><blockquote><p>Input:&emsp;”pwwkew”<br>Output:&emsp;”3”<br>Explanation: The answer is “wke”, with the length of 3.<br>             Note that the answer must be a substring, “pwke” is a subsequence and not a </p></blockquote><p>此题可以通过滑动窗口的思想来解决，代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int lengthOfLongestSubstring(string s)</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; arr(128,-1);</span><br><span class="line">    int left = -1,res = 0;  //滑动窗口的左边和返回值</span><br><span class="line">    for (int i = 0;i &lt; s.size();++i) &#123;</span><br><span class="line">        left = max(left,arr[s[i]);</span><br><span class="line">        arr[s[i] = i;</span><br><span class="line">        res = max(res,i-left);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-Review"><a href="#2-Review" class="headerlink" title="2.Review"></a>2.Review</h2><p><a href="https://medium.com/@mr_mig_by/how-do-i-learn-some-functional-programming-3b28875a0bc3" target="_blank" rel="noopener">我该怎样去学习一些函数式编程?</a><br>本篇文章从OOD到函数式编程，没过于讲解技术上面的知识，不过作者推荐了一些文章讲述了该怎么去学习函数式编程，比如第一推荐了《Function JavaScript》,和使用underscore library，当熟练了这些下一步就可以深入。《JavaScript Allongé》,《Professor Frisby’s Mostly Adequate Guide to Functional Programming.》，并且还推荐了haskell。这篇文章主要是”Tell us how to learn it”，对函数式编程感兴趣的朋友可以点击阅读下</p><h2 id="3-Tip"><a href="#3-Tip" class="headerlink" title="3.Tip"></a>3.Tip</h2><p>关于Tip，说一下这周学的怎么计算子网地址，子网掩码和一个子网内主机数吧<br>例如一个IP地址是203.123.1.135,子网掩码是255.255.255.192   </p><p>那子网地址:就是用IP地址和子网掩码进行按位与运算，这里也就是132&amp;192=128，所以子网地址这个ip地址对应的子网地址是203.123.1.128</p><p>子网主机数:将子网掩码转成二进制,11111111.11111111.11111111.11000000 其中为1的表示网络位，为0表示主机位。主机位总共占6位，主机数就等于2^6-2=62，减去的2代表的是 子网地址和直接广播地址。</p><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>这周没什么分享的，因为最近这一两个月都太忙了，工作上、生活上，自我学习上都挺忙的，没有什么太值得分享的东西。倒是可以分享下之前感到很郁闷的东西，我朋友大概知道 相对于技术，我一直比较反感windows下mfc开发的那一套和不太愿意去接触web端的东西，不过最近工作上从duilib到mfc是干的真的很糟心，没有激情没有想去学习mfc的动力，所以以致于工作上出现很多问题。  </p><p>过渡了一个月，看到耗子叔的专栏，心态有了些变化。正如专栏里说的和我自己理解的，其实自己并不是反感windows，偏好linux开发。反而是由于linux简单，windows比较复杂产生的抵抗情绪。调节了一下心态，活到老，学到老。I’m not perfect.But I keep trying.</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><blockquote><p>PS:能把心态调节过来，个人认为跟自己最近阅读的书籍有一定联系，所以在这里也推荐几本刚刚看完的书，希望小伙伴们能一起交流。  </p><p>《一个人的朝圣》 很多人认为是鸡汤，其实我并不这样认为，作者只不过是讲述了哈罗德一个人朝圣的故事与你我无关<br>《情人》  小波同志力荐的一本小说<br>《海边的卡夫卡》</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;What’s ARTS？&lt;br&gt;A:Algorithm 每周至少做一个leetcode的算法题&lt;br&gt;R:Review 阅读并点评至少一遍英文技术文章&lt;br&gt;T:Tip 学习至少一个技术技巧&lt;br&gt;S:Share 分享一篇有观点和思考的技术文章  
      
    
    </summary>
    
      <category term="ARTS" scheme="https://thorns.cn/categories/ARTS/"/>
    
    
  </entry>
  
  <entry>
    <title>ARTS 打卡第一周</title>
    <link href="https://thorns.cn/2019/03/23/ARTS_1.html"/>
    <id>https://thorns.cn/2019/03/23/ARTS_1.html</id>
    <published>2019-03-22T16:39:47.000Z</published>
    <updated>2019-03-22T16:44:56.904Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>What’s ARTS？<br>A:Algorithm 每周至少做一个leetcode的算法题<br>R:Review 阅读并点评至少一遍英文技术文章<br>T:Tip 学习至少一个技术技巧<br>S:Share 分享一篇有观点和思考的技术文章  </p></blockquote><font size="5">ARTS打卡第一周</font><h2 id="1-Algorithm"><a href="#1-Algorithm" class="headerlink" title="1.Algorithm"></a>1.Algorithm</h2><p>&emsp;本周做了几个难度为Easy的算法，记录下。</p><h3 id="1-1-Palindromic-number"><a href="#1-1-Palindromic-number" class="headerlink" title="1.1 Palindromic number"></a>1.1 Palindromic number</h3><p>&emsp;判断一个数是否为回文数,方法很简单，只需要逆置前后判断是否相等就行了，不过还是有几个地方需要注意下   </p><p>&emsp;1. 负数、个位上为0的数都不是回文数<br>&emsp;2. 注意int类型的溢出  </p><p>&emsp;代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">bool determine(int num)</span><br><span class="line">&#123;</span><br><span class="line">    if (num &lt; 0 ||(num != 0) &amp;&amp; num %10 ==0)</span><br><span class="line">        return false;</span><br><span class="line">    int x = 0;</span><br><span class="line">    while (num &gt; x) &#123;</span><br><span class="line">        x = num % 10 + x * 10;</span><br><span class="line">        num /= 10;</span><br><span class="line">    &#125;</span><br><span class="line">    return num == x || (x / 10 == y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="1-2-Roman-To-Intger"><a href="#1-2-Roman-To-Intger" class="headerlink" title="1.2 Roman To Intger"></a>1.2 Roman To Intger</h3><p>&emsp;将罗马数字转换为整数，此题感觉主要考查对罗马数字的转换熟悉不，当一个罗马数字前面部分小于后面部分，就是使用后面部分减去前面部分，否则就是加。第一时间想到的是直接使用个switch进行判断就好了,不过这样不够简洁，到最后发现有更简洁的办法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">int romantoint(string str)</span><br><span class="line">&#123;</span><br><span class="line">    int num[26] = &#123;0&#125;;</span><br><span class="line">    num[&apos;I&apos;-&apos;A&apos;] = 1;</span><br><span class="line">    num[&apos;V&apos;-&apos;A&apos;] = 5;</span><br><span class="line">    num[&apos;X&apos;-&apos;A&apos;] = 10;</span><br><span class="line">    num[&apos;L&apos;-&apos;A&apos;] = 50;</span><br><span class="line">    num[&apos;C&apos;-&apos;A&apos;] = 100;</span><br><span class="line">    num[&apos;D&apos;-&apos;A&apos;] = 500;</span><br><span class="line">    num[&apos;M&apos;-&apos;A&apos;] = 1000;</span><br><span class="line">    </span><br><span class="line">    int sum = 0;</span><br><span class="line">    for (size_t i = 0; i &lt; str.size(); ++i) &#123;</span><br><span class="line">        if (i+1 = str.size()) &#123;</span><br><span class="line">            sum += num[str[i]-&apos;A&apos;];</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        if (num[str[i]-&apos;A&apos;] &gt;= num[str[i+1]-&apos;A&apos;]) </span><br><span class="line">            sum += num[str[i]-&apos;A&apos;];</span><br><span class="line">        else &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            sum += num[str[i]-&apos;A&apos;] - num[str[i-1]-&apos;A&apos;];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-Review"><a href="#2-Review" class="headerlink" title="2.Review"></a>2.Review</h2><p>&emsp;<a href="https://medium.com/@calebleak/fast-virtual-functions-hacking-the-vtable-for-fun-and-profit-25c36409c5e0" target="_blank" rel="noopener">文章链接-需要能打开Google才能打开</a><br>&emsp;这篇文章讲述了C++虚函数的性能开销，从重载、override 多态一步步到虚函数，写的很详细。也从各方面分析了虚函数的开销，主要体现在虚函数调用需要间接跳转带来的分支预测成本和cache miss，文章中也讲了该如何尽可能的去最小化cache miss，通过虚函数分组的办法使用std::set来进行分组{函数指针,对象指针},通过分组将函数调用保存在缓存中最小化cache miss。</p><h2 id="3-Tip"><a href="#3-Tip" class="headerlink" title="3.Tip"></a>3.Tip</h2><p>&emsp;前面先说一下，感觉学习真的是一个不断完善、不断修剪的过程，本周学到的tips都跟上面讲的文章相关。看到文章中提到的cache miss，才知道cache miss是什么东西，也才学会使用linux下的性能调优工具perf.  </p><ol><li><p>perf list 查看perf能监控哪些性能指标 主要有三类指标<br>1.1 Hardware Event 是由PMU硬件产生的事件 比如cache命中<br>1.2 Software Event 由内核产生，比如进程切换,page-faults等<br>1.3 TracePoint Event 是核心中的静态 tracepoint 所触发的事件，这些 tracepoint 用來判断在程序执行时期核心的行为  </p></li><li><p>perf stat -e -L1-dcache-load-misses ./test  查看test程序的L1 cache miss的指标</p></li></ol><h2 id="4-Share"><a href="#4-Share" class="headerlink" title="4. Share"></a>4. Share</h2><p>关于技术文章,这周看的比较多的是耗子叔的文章，里面有一篇很有意思，讲的是“魔数 Ox5f3759df” ，主要讲的是求平方根，硬是看了好几遍，才看懂，后面又看到用牛顿迭代法求平方根，都很不错，分享给大家，有兴趣的小伙伴可以留言一起讨论讨论。<br><a href="https://matongxue.com/madocs/205.html" target="_blank" rel="noopener">如何通俗易懂地讲解牛顿迭代法–戳我打开</a>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;What’s ARTS？&lt;br&gt;A:Algorithm 每周至少做一个leetcode的算法题&lt;br&gt;R:Review 阅读并点评至少一遍英文技术文章&lt;br&gt;T:Tip 学习至少一个技术技巧&lt;br&gt;S:Share 分享一篇有观点和思考的技术文章  
      
    
    </summary>
    
      <category term="ARTS" scheme="https://thorns.cn/categories/ARTS/"/>
    
    
      <category term="ARTS" scheme="https://thorns.cn/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>C++ 单例模式 双检锁问题</title>
    <link href="https://thorns.cn/2019/03/09/DCLP.html"/>
    <id>https://thorns.cn/2019/03/09/DCLP.html</id>
    <published>2019-03-09T06:35:40.000Z</published>
    <updated>2019-03-09T09:21:08.315Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-单例模式和双检锁问题"><a href="#C-单例模式和双检锁问题" class="headerlink" title="C++ 单例模式和双检锁问题"></a>C++ 单例模式和双检锁问题</h1><blockquote><p>最近在看《程序员的自我修养》这本书，从代码的编译到链接，从虚拟空间映射物理空间，到内存的分配无一不通通展开。以前对编译，链接不了解、疑惑的地方在看这本书时都有一种豁然开朗的感觉，特此记录一下。</p></blockquote><p>&emsp;在设计模式中，单例模式算的上最容易理解简单，且经常用到的一种模式。单例模式又分为“饿汉式”和“懒汉式”两种模式。  </p><ul><li>懒汉式:需要类的实例化时去判断唯一实例是否被实例化，如果没有才会去创建实例</li><li>饿汉式:在类定义的时候，唯一实例就已经进行实例化，后面需要用到时，直接返回唯一实例</li></ul><h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//单线程安全</span><br><span class="line">T *GetInstance()</span><br><span class="line">&#123;</span><br><span class="line">    if (pInst == NULL)</span><br><span class="line">        pInst = new T;</span><br><span class="line">    return pInst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码，是单线程安全的，但并不是多线程安全。考虑一下有两个线程A和B，同时调用了GetInstance方法又恰巧检测到pInst为NULL，这时就出问题了，产生了两个实例，这并不是我们想要的。接下来，我们肯定会想到线程不安全加锁就完了嘛。  </p><h2 id="双检锁-懒汉式"><a href="#双检锁-懒汉式" class="headerlink" title="双检锁-懒汉式"></a>双检锁-懒汉式</h2><p>下面是经典的加锁懒汉式实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">T *GetInstance()</span><br><span class="line">&#123;</span><br><span class="line">    //进行double-check,降低多线程每次调用lock带来的开销</span><br><span class="line">    if (pInst == NULL) &#123;</span><br><span class="line">        lock();</span><br><span class="line">        if (pInst == NULL)</span><br><span class="line">            pInst = new T;</span><br><span class="line">        unlock();      </span><br><span class="line">    &#125;</span><br><span class="line">    return pInst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;这里的双重if检测(double-check)，是为了降低多线程每次调用lock带来的开销。也许当我们看到这样的代码时，认为并没有问题，实际上是有问题的，问题来自CPU的乱序执行。<br>&emsp;我们知道C++的new，包含了两个步骤   </p><blockquote><ol><li>分配内存  </li><li>调用构造函数  </li></ol></blockquote><p>&emsp;所以pInst=new T包含了三个步骤</p><blockquote><ol><li>分配内存  </li><li>调用构造函数</li><li>将分配好的内存地址赋值给pInst </li></ol></blockquote><p>事实上在cpu执行的时候，步骤2和3是可以颠倒的，他们看上去像这样  </p><blockquote><ol><li>调用operator new()分配内存  </li><li>使pInst指向分配好的内存</li><li>调用构造函数constructor  </li></ol></blockquote><p>那在多线程的情况下，就可能会出现A线程刚好分配好内存，并赋值给pInst，B线程再次调用GetInstance方法，此时pInst已经不为空了，所以就会出现将一个还并没有构造完毕的对象直接返回给用户使用，此时问题就出现了</p><h2 id="解决方法，使用barrier指令"><a href="#解决方法，使用barrier指令" class="headerlink" title="解决方法，使用barrier指令"></a>解决方法，使用barrier指令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#define barrier() __asm__ volatile (&quot;lwsync&quot;)</span><br><span class="line">T *GetInstance()</span><br><span class="line">&#123;</span><br><span class="line">    if (pInst == NULL) &#123;</span><br><span class="line">        lock();</span><br><span class="line">        if (pInst == NULL) &#123;</span><br><span class="line">            T *temp = new T;</span><br><span class="line">            barrier();</span><br><span class="line">            pInst = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        unlock();      </span><br><span class="line">    &#125;</span><br><span class="line">    return pInst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;通常情况下是调用cpu提供的一条指令，这条指令的作用是会阻止cpu将该指令之前的指令交换到该指令之后，这条指令也通常被叫做barrier。 上面代码中的<strong>asm</strong>表示这个是一条汇编指令，volatile是可选的，如果用了它，则表示向编译器声明不允许对该汇编指令进行优化。lwsync是POWERPC提供的barrier指令。<br>&emsp;最后,在C++11中，关于C++双检锁的问题，已经完全解决了，有兴趣的朋友可以去看下C++11 DCLP</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-单例模式和双检锁问题&quot;&gt;&lt;a href=&quot;#C-单例模式和双检锁问题&quot; class=&quot;headerlink&quot; title=&quot;C++ 单例模式和双检锁问题&quot;&gt;&lt;/a&gt;C++ 单例模式和双检锁问题&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;最近在看《程序员的自我修养
      
    
    </summary>
    
      <category term="C++" scheme="https://thorns.cn/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>蒲公英和炊烟都在等你</title>
    <link href="https://thorns.cn/2019/01/19/dandelion.html"/>
    <id>https://thorns.cn/2019/01/19/dandelion.html</id>
    <published>2019-01-18T20:27:00.000Z</published>
    <updated>2019-07-15T03:15:23.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="蒲公英和炊烟都在等你"><a href="#蒲公英和炊烟都在等你" class="headerlink" title="蒲公英和炊烟都在等你"></a>蒲公英和炊烟都在等你</h1><blockquote><p>蒲公英和炊烟都在等你，你的孩子一直很乖  </p></blockquote><p><img src="http://image.thorns.cn/mama.jpeg" alt="avatar"><br>&emsp;睡下的时候，应是周五的十一点十几分，挂断了朋友的电话对他轻轻的讲了句”我要睡了”。收拾好因找不到一包烟，被我翻的乱七八糟的房间，躺在床上，记忆中很久没有这么早睡过了，不知道为什么从跨年去南京一趟，回来到现在整个人都很累，有身体上的疲惫有精神上的面对。   </p><p>&emsp;我想今天晚上或许会有点不同，房间是干净的，昏黄的灯光折射出十来平的小窝，显得别具一格的宽阔不会被人潮拥挤。脑海中回响”四点多的时候应该会醒来”，醒来时却发现比预想提前了两个小时。总感觉会发生点什么，在这个夜晚会不一样。</p><h2 id="1-19-2-53"><a href="#1-19-2-53" class="headerlink" title="1.19 2:53"></a>1.19 2:53</h2><p>在 1月19日凌晨两点五十三分床上的手机屏幕亮了，像是久违的一束阳光照在我脸膛，手机屏幕传来的是网易云音乐上别人给我点赞的消息，是我在李志的《妈妈》下面</p><blockquote><p>“我想这首歌 评论没有上万。都是害怕去听吧。”     </p></blockquote><p>&emsp;这首歌按李逼一贯的风格有很多个版本，最先发布在《这个世界会好吗》专辑下，还有“13live”,“14io”，个人听歌比较钟爱于live，追求真实，身入其镜的感觉。也就开始了“13live版”的《妈妈》。</p><h2 id="红色推土机"><a href="#红色推土机" class="headerlink" title="红色推土机"></a>红色推土机</h2><p>&emsp;也许是某一天，实在忍受不了没日没夜的单曲循环，发了疯似的把李志的歌全部收集到了歌单里面，列表循环在歌声缓缓流入耳朵不经意间发现了《妈妈》这首歌还有另外一个不为大众知道的版本，——“红色推土机”  </p><p>&emsp;故事的开始貌似都是以时间作分割。</p><blockquote><p>09年，民谣歌手周云蓬发起了一个帮助贫困盲童的计划。目的是为那些家境贫困的失明孩子，购买他们需要的乐器、mp3播放器、读书机。   为了让更多的人知道这个计划，周云蓬邀请众多民谣歌手无偿录制了一个童谣专辑，每个歌手或翻唱、或原创一首童谣歌曲，一共25首儿歌收录在两张CD中，专辑名字为《红色推土机》。这张专辑把当下“新民谣”阵营里的歌手一网打尽，称得上是民谣歌手的一张全家福。而这些创作音乐人，在这一次的专辑里，也从往日的角色中越轨而出，放下沉重，低吟浅唱，唱给暂时的黑暗和永远的孩子。    </p></blockquote><p>&emsp;真巧，李志这首《妈妈》也在其中，对伴奏进行了些许改变，试听了一下，这首歌的伴奏是这几个版本中是我最喜欢的，也是我最害怕的，好像是有种束缚或者规则，限制了人越喜欢的东西越害怕失去，害怕损坏，害怕别人知道，害怕得不到….害怕去听。整首歌给我的感觉是 太多太多的消极，负面情绪如海啸袭来将你淹没，将你的身子冲刷在海底。扫了扫留言看到一条很真实很特别的评论</p><blockquote><p>昨晚叁叁肆汉中场，逼哥唱这首歌时，那句”你的孩子一直很乖”唱成了”你的孩子一直很怪”,当时在现场的我真的是止不住的掉。妈妈，”你的孩子一直很怪”</p></blockquote><p>&emsp;好奇点头像进去，翻了翻您的动态，又看到一条特别的动态，静悄悄地留了一句 “蒲公英和炊烟都在等你”。接着在自己动态里分享了这首歌，也留下了一句——“2019 1.14 5:10”。</p><h2 id="您的孩子一直很乖"><a href="#您的孩子一直很乖" class="headerlink" title="您的孩子一直很乖"></a>您的孩子一直很乖</h2><blockquote><p>写歌的人最无情，听歌的人假正经    </p></blockquote><p>&emsp;最害怕忽然听懂一首歌，看懂一本书，明白一个道理。就像李宗盛的歌写道“春风再美也比不上你的笑，没见过你的人不会明了”,有时候明了的人真明了，不明了的人永远也不会明了。</p><p>&emsp;记录到这，不想在记录了，因为已经凌晨四点了，该睡了明天还要”“噢！不 是今天”——还要继续过着充实且有趣的生活。<br>&emsp;我相信在每个夜晚，歌里面会告诉我一切。  </p><p>&emsp;收到网易云通知消息的时候，在此后的一分钟对您发了一句”真巧”。——“真巧”<br><img src="http://image.thorns.cn/qiao.jpeg" alt="avatar"></p><h1 id="您的孩子一直很怪"><a href="#您的孩子一直很怪" class="headerlink" title="您的孩子一直很怪"></a>您的孩子一直很怪</h1><p>蒲公英和炊烟都在等你<br>您的孩子一直很乖<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;——于2019 1.19 4:27</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;蒲公英和炊烟都在等你&quot;&gt;&lt;a href=&quot;#蒲公英和炊烟都在等你&quot; class=&quot;headerlink&quot; title=&quot;蒲公英和炊烟都在等你&quot;&gt;&lt;/a&gt;蒲公英和炊烟都在等你&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;蒲公英和炊烟都在等你，你的孩子一直很乖  &lt;/p&gt;
      
    
    </summary>
    
      <category term="李志" scheme="https://thorns.cn/categories/%E6%9D%8E%E5%BF%97/"/>
    
    
  </entry>
  
  <entry>
    <title>String to Integer</title>
    <link href="https://thorns.cn/2019/01/07/String%20to%20Integer.html"/>
    <id>https://thorns.cn/2019/01/07/String to Integer.html</id>
    <published>2019-01-07T13:47:47.000Z</published>
    <updated>2019-01-08T07:44:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="String-to-Integer-atoi"><a href="#String-to-Integer-atoi" class="headerlink" title=" String to Integer(atoi) "></a><font face="Calibri" size="6"> String to Integer(atoi) </font></h1><h2 id="原题描述"><a href="#原题描述" class="headerlink" title="原题描述"></a>原题描述</h2><blockquote><p>Implement atoi which converts a string to an integer.<br>实现c语言中的atoi函数,将string类型转化成int</p></blockquote><p>实现时需要考虑的因素有:  </p><ol><li>溢出问题  </li><li>输入无效</li><li>丢弃所有空格</li><li>数字正负号</li></ol><p>关于溢出，对于像我这种记不清楚int32范围的人，可以直接用long long类型解决。<br>数字正负号可以使用一个标志位进行标识，代码如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">int myAtoi(string str)</span><br><span class="line">&#123;</span><br><span class="line">    int flag = 0,pos = 0;</span><br><span class="line">    long long number = 0;</span><br><span class="line">    </span><br><span class="line">    //丢弃前面的空白字符串</span><br><span class="line">    while (str[pos] == &apos; &apos;) </span><br><span class="line">        pos++;</span><br><span class="line">    //判断正负号,下标移到符号下一位</span><br><span class="line">    if (str[pos] == &apos;-&apos; || str[pos] == &apos;+&apos;)</span><br><span class="line">        flag = str[pos++] == &apos;-&apos; ? -1:1;</span><br><span class="line">    </span><br><span class="line">    while (str[pos] &gt;= &apos;0&apos; &amp;&amp; str[pos] &lt;= &apos;9&apos;) &#123;</span><br><span class="line">        number = 10 * number + (str[pos++]-&apos;0&apos;);</span><br><span class="line">        //判断是否超过int32的范围</span><br><span class="line">        if (number &gt;INT_MAX)</span><br><span class="line">            return flag == 1 ? INT_MAX:INT_MIN;</span><br><span class="line">    &#125;</span><br><span class="line">    return (int)(number * flag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;String-to-Integer-atoi&quot;&gt;&lt;a href=&quot;#String-to-Integer-atoi&quot; class=&quot;headerlink&quot; title=&quot; String to Integer(atoi) &quot;&gt;&lt;/a&gt;&lt;font face=&quot;Calib
      
    
    </summary>
    
      <category term="leetcode" scheme="https://thorns.cn/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Reverse interger</title>
    <link href="https://thorns.cn/2019/01/06/Reverse%20interger.html"/>
    <id>https://thorns.cn/2019/01/06/Reverse interger.html</id>
    <published>2019-01-05T17:47:47.000Z</published>
    <updated>2019-01-08T07:53:10.457Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Reverse-interger"><a href="#Reverse-interger" class="headerlink" title="Reverse interger"></a>Reverse interger</h1><p>将一个整数反转，需要考虑溢出。<br>leetcode 原题链接：<a href="https://leetcode.com/problems/reverse-integer/" target="_blank" rel="noopener">https://leetcode.com/problems/reverse-integer/</a><br>example: x=123,return 321<br>example: x=-123,return -321<br>此题难度easy，不过需要考虑的是反转之后溢出情况。int32的范围-2147483648,2147483647。直接贴代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int reverse(int x)</span><br><span class="line">&#123;</span><br><span class="line">    int res = 0;</span><br><span class="line">    while (x != 0) &#123;</span><br><span class="line">        //判断是否溢出</span><br><span class="line">        if (abs(res) &gt; INT_MAX/10)</span><br><span class="line">            return 0;</span><br><span class="line">        res = res *10 + x % 10;</span><br><span class="line">        x /= 10;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当然也可以定义一个long long类型的变量，如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//解法2</span><br><span class="line">int reverse(int x)</span><br><span class="line">&#123;</span><br><span class="line">    long long res=0;</span><br><span class="line">    while (x != 0) &#123;</span><br><span class="line">        res = res *10 + x % 10;</span><br><span class="line">        x /= 10;</span><br><span class="line">    &#125;</span><br><span class="line">    //判断溢出</span><br><span class="line">    return (res&gt;INT_MAX||res&lt;INT_MIN)?0:res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>解法一，是直接判断是否大于INT_MAX/10(即214748364)，当res&gt;214748364时，必定溢出。因为x的第一位只能是1或者2，所以再执行res=res*10+x/10就会溢出。<br>解法二，直接定义了一个long long类型，最后判断是否大于INT_MAX或者小于INT_MIN。个人推荐解法一。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Reverse-interger&quot;&gt;&lt;a href=&quot;#Reverse-interger&quot; class=&quot;headerlink&quot; title=&quot;Reverse interger&quot;&gt;&lt;/a&gt;Reverse interger&lt;/h1&gt;&lt;p&gt;将一个整数反转，需要考虑溢出
      
    
    </summary>
    
      <category term="leetcode" scheme="https://thorns.cn/categories/leetcode/"/>
    
    
  </entry>
  
</feed>
